# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-03-20 20:30+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/cancel_a_graph.rst:4
msgid "Cancel a Graph Explicitly"
msgstr "Отмена графа в явном виде"

#: ../../oneTBB/doc/main/tbb_userguide/cancel_a_graph.rst:7
msgid "To cancel a graph execution without an exception, you can create the graph using an explicit task_group_context, and then call cancel_group_execution() on that object. This is done in the example below:"
msgstr "Чтобы отменить выполнение графа без исключения, ты можешь создать граф, используя явный task_group_context, а затем вызвать cancel_group_execution() на этом объекте. Это сделано в примере ниже:"

#: ../../oneTBB/doc/main/tbb_userguide/cancel_a_graph.rst:16
msgid ""
"task_group_context t;\n"
"graph g(t);\n"
"\n"
"\n"
"function_node< int, int > f1( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"function_node< int, int > f2( g, 1,\n"
"    []( const int i ) -> int {\n"
"        cout << \"Begin \" << i << \"\\n\";\n"
"        spin_for(0.2);\n"
"        cout << \"End \" << i << \"\\n\";\n"
"        return i;\n"
"} );\n"
"\n"
"\n"
"function_node< int, int > f3( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"make_edge( f1, f2 );\n"
"make_edge( f2, f3 );\n"
"f1.try_put(1);\n"
"f1.try_put(2);\n"
"spin_for(0.1);\n"
"t.cancel_group_execution();\n"
"g.wait_for_all();"
msgstr ""
"task_group_context t;\n"
"graph g(t);\n"
"\n"
"\n"
"function_node< int, int > f1( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"function_node< int, int > f2( g, 1,\n"
"    []( const int i ) -> int {\n"
"        cout << \"Begin \" << i << \"\\n\";\n"
"        spin_for(0.2);\n"
"        cout << \"End \" << i << \"\\n\";\n"
"        return i;\n"
"} );\n"
"\n"
"\n"
"function_node< int, int > f3( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"make_edge( f1, f2 );\n"
"make_edge( f2, f3 );\n"
"f1.try_put(1);\n"
"f1.try_put(2);\n"
"spin_for(0.1);\n"
"t.cancel_group_execution();\n"
"g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/cancel_a_graph.rst:44
msgid "When a graph execution is canceled, any node that has already started to execute will execute to completion, but any node that has not started to execute will not start. So in the example above, f2 will print both the Begin and End message for input 1, but will not receive the input 2."
msgstr "Когда выполнение графа отменяется, любой узел, который уже начал выполняться, выполнится до завершения, но любой узел, который не начал выполняться, не запустится. Поэтому в приведенном выше примере f2 напечатает и сообщение о начале, и сообщение о завершении для входа 1, но не получит вход 2."

#: ../../oneTBB/doc/main/tbb_userguide/cancel_a_graph.rst:50
msgid "You can also get the task_group_context that a node belongs to from within the node body and use it to cancel the execution of the graph it belongs to:"
msgstr "Ты также можешь получить task_group_context, к которому принадлежит узел, из тела узла и использовать его для отмены выполнения графа, к которому он принадлежит:"

#: ../../oneTBB/doc/main/tbb_userguide/cancel_a_graph.rst:58
msgid ""
"graph g;\n"
"\n"
"\n"
"function_node< int, int > f1( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"function_node< int, int > f2( g, 1,\n"
"    []( const int i ) -> int {\n"
"     cout << \"Begin \" << i << \"\\n\";\n"
"     spin_for(0.2);\n"
"        cout << \"End \" << i << \"\\n\";\n"
"        task::self().group()->cancel_group_execution();\n"
"        return i;\n"
"} );\n"
"\n"
"\n"
"function_node< int, int > f3( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"make_edge( f1, f2 );\n"
"make_edge( f2, f3 );\n"
"f1.try_put(1);\n"
"f1.try_put(2);\n"
"g.wait_for_all();"
msgstr ""
"graph g;\n"
"\n"
"\n"
"function_node< int, int > f1( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"function_node< int, int > f2( g, 1,\n"
"    []( const int i ) -> int {\n"
"     cout << \"Begin \" << i << \"\\n\";\n"
"     spin_for(0.2);\n"
"        cout << \"End \" << i << \"\\n\";\n"
"        task::self().group()->cancel_group_execution();\n"
"        return i;\n"
"} );\n"
"\n"
"\n"
"function_node< int, int > f3( g, 1, []( int i ) {  return i; } );\n"
"\n"
"\n"
"make_edge( f1, f2 );\n"
"make_edge( f2, f3 );\n"
"f1.try_put(1);\n"
"f1.try_put(2);\n"
"g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/cancel_a_graph.rst:84
msgid "You can get the task_group_context from a node's body even if the graph was not explicitly passed one at construction time."
msgstr "Ты можешь получить task_group_context из тела узла, даже если графу не был явно передан таковой во время построения."
