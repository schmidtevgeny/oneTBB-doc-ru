# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 14:15+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:4
msgid "GUI Thread"
msgstr "Поток GUI"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst
msgid "Problem"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:12
msgid "A user interface thread must remain responsive to user requests, and must not get bogged down in long computations."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst
msgid "Context"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:22
msgid "Graphical user interfaces often have a dedicated thread (\"GUI thread\") for servicing user interactions. The thread must remain responsive to user requests even while the application has long computations running. For example, the user might want to press a \"cancel\" button to stop the long running computation. If the GUI thread takes part in the long running computation, it will not be able to respond to user requests."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst
msgid "Forces"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:37
msgid "The GUI thread services an event loop."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:40
msgid "The GUI thread needs to offload work onto other threads without waiting for the work to complete."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:44
msgid "The GUI thread must be responsive to the event loop and not become dedicated to doing the offloaded work."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst
msgid "Related"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:54
msgid "Non-Preemptive Priorities"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:55
msgid "Local Serializer"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst
msgid "Solution"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:64
msgid "The GUI thread offloads the work by firing off a task to do it using method ``task_arena::enqueue`` of a ``task_arena`` instance. When finished, the task posts an event to the GUI thread to indicate that the work is done. The semantics of ``enqueue`` cause the task to eventually run on a worker thread distinct from the calling thread."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:70
msgid "The following figure sketches the communication paths. Items in black are executed by the GUI thread; items in blue are executed by another thread."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:73
msgid "|image0|"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:203
msgid "image0"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:203
msgid ".. image:: main/tbb_userguide/design_patterns/Images/image007a.jpg"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst
msgid "Example"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:81
msgid "The example is for the Microsoft Windows\\* operating systems, though similar principles apply to any GUI using an event loop idiom. For each event, the GUI thread calls a user-defined function ``WndProc`` to process an event."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:89
msgid ""
"// Event posted from enqueued task when it finishes its work.\n"
"const UINT WM_POP_FOO = WM_USER+0;\n"
"\n"
"\n"
"// Queue for transmitting results from enqueued task to GUI thread.\n"
"oneapi::tbb::concurrent_queue<Foo>ResultQueue;\n"
"\n"
"\n"
"// GUI thread's private copy of most recently computed result.\n"
"Foo CurrentResult;\n"
"\n"
"\n"
"LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n"
"   switch(msg) {\n"
"       case WM_COMMAND:\n"
"           switch (LOWORD(wParam)) {\n"
"               case IDM_LONGRUNNINGWORK:\n"
"                   // User requested a long computation. Delegate it to another thread.\n"
"                   LaunchLongRunningWork(hWnd);\n"
"                   break;\n"
"               case IDM_EXIT:\n"
"                   DestroyWindow(hWnd);\n"
"                   break;\n"
"               default:\n"
"                   return DefWindowProc(hWnd, msg, wParam, lParam);\n"
"           }\n"
"           break;\n"
"       case WM_POP_FOO:\n"
"           // There is another result in ResultQueue for me to grab.\n"
"           ResultQueue.try_pop(CurrentResult);\n"
"           // Update the window with the latest result.\n"
"           RedrawWindow( hWnd, NULL, NULL, RDW_ERASE|RDW_INVALIDATE );\n"
"           break;\n"
"       case WM_PAINT:\n"
"           Repaint the window using CurrentResult\n"
"           break;\n"
"       case WM_DESTROY:\n"
"           PostQuitMessage(0);\n"
"           break;\n"
"       default:\n"
"           return DefWindowProc( hWnd, msg, wParam, lParam );\n"
"   }\n"
"   return 0;\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:135
msgid "The GUI thread processes long computations as follows:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:138
msgid "The GUI thread calls ``LongRunningWork``, which hands off the work to a worker thread and immediately returns."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:142
msgid "The GUI thread continues servicing the event loop. If it has to repaint the window, it uses the value of\\ ``CurrentResult``, which is the most recent ``Foo`` that it has seen."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:147
msgid "When a worker finishes the long computation, it pushes the result into ResultQueue, and sends a message WM_POP_FOO to the GUI thread."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:151
msgid "The GUI thread services a ``WM_POP_FOO`` message by popping an item from ResultQueue into CurrentResult. The ``try_pop`` always succeeds because there is exactly one ``WM_POP_FOO`` message for each item in ``ResultQueue``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:157
msgid "Routine ``LaunchLongRunningWork`` creates a function task and launches it using method ``task_arena::enqueue``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:163
msgid ""
"class LongTask {\n"
"   HWND hWnd;\n"
"   void operator()() {\n"
"       Do long computation\n"
"       Foo x = result of long computation\n"
"       ResultQueue.push( x );\n"
"       // Notify GUI thread that result is available.\n"
"       PostMessage(hWnd,WM_POP_FOO,0,0);\n"
"   }\n"
"public:\n"
"   LongTask( HWND hWnd_ ) : hWnd(hWnd_) {}\n"
"};\n"
"\n"
"void LaunchLongRunningWork( HWND hWnd ) {\n"
"   oneapi::tbb::task_arena a;\n"
"   a.enqueue(LongTask(hWnd));\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:182
msgid "It is essential to use method ``task_arena::enqueue`` here. Even though, an explicit ``task_arena`` instance is created, the method ``enqueue`` ensures that the function task eventually executes when resources permit, even if no thread explicitly waits on the task. In contrast, ``oneapi::tbb::task_group::run`` may postpone execution of the function task until it is explicitly waited upon with the ``oneapi::tbb::task_group::wait``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:188
msgid "The example uses a ``concurrent_queue`` for workers to communicate results back to the GUI thread. Since only the most recent result matters in the example, and alternative would be to use a shared variable protected by a mutex. However, doing so would block the worker while the GUI thread was holding a lock on the mutex, and vice versa. Using ``concurrent_queue`` provides a simple robust solution."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/GUI_Thread.rst:195
msgid "If two long computations are in flight, there is a chance that the first computation completes after the second one. If displaying the result of the most recently requested computation is important, then associate a request serial number with the computation. The GUI thread can pop from ``ResultQueue`` into a temporary variable, check the serial number, and update ``CurrentResult`` only if doing so advances the serial number."
msgstr ""
