# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 14:16+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:4
msgid "Agglomeration"
msgstr "Агломерация"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst
msgid "Problem"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:13
msgid "Parallelism is so fine grained that overhead of parallel scheduling or communication swamps the useful work."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst
msgid "Context"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:23
msgid "Many algorithms permit parallelism at a very fine grain, on the order of a few instructions per task. But synchronization between threads usually requires orders of magnitude more cycles. For example, elementwise addition of two arrays can be done fully in parallel, but if each scalar addition is scheduled as a separate task, most of the time will be spent doing synchronization instead of useful addition."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst
msgid "Forces"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:37
msgid "Individual computations can be done in parallel, but are small. For practical use of |full_name|, \"small\" here means less than 10,000 clock cycles."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:42
msgid "The parallelism is for sake of performance and not required for semantic reasons."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst
msgid "Solution"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:52
msgid "Group the computations into blocks. Evaluate computations within a block serially."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:56
msgid "The block size should be chosen to be large enough to amortize parallel overhead. Too large a block size may limit parallelism or load balancing because the number of blocks becomes too small to distribute work evenly across processors."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:62
msgid "The choice of block topology is typically driven by two concerns:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:65
msgid "Minimizing synchronization between blocks."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:68
msgid "Minimizing cache traffic between blocks."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:71
msgid "If the computations are completely independent, then the blocks will be independent too, and then only cache traffic issues must be considered."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:76
msgid "If the loop is \"small\", on the order of less than 10,000 clock cycles, then it may be impractical to parallelize at all, because the optimal agglomeration might be a single block,"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst
msgid "Examples"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:87
msgid "TBB loop templates such as ``oneapi::tbb::parallel_for`` that take a *range* argument support automatic agglomeration."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:91
msgid "When agglomerating, think about cache effects. Avoid having cache lines cross between groups if possible."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:95
msgid "There may be boundary to interior ratio effects. For example, if the computations form a 2D grid, and communicate only with nearest neighbors, then the computation per block grows quadratically (with the block's area), but the cross-block communication grows with linearly (with the block's perimeter). The following figure shows four different ways to agglomerate an 8×8 grid. If doing such analysis, be careful to consider that information is transferred in cache line units. For a given area, the perimeter may be minimized when the block is square with respect to the underlying grid of cache lines, not square with respect to the logical grid."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:111
msgid "Four different agglomerations of an 8×8 grid. |image0|"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:165
msgid "image0"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:165
msgid ".. image:: main/tbb_userguide/design_patterns/Images/image002a.jpg"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:114
msgid "Also consider vectorization. Blocks that contain long contiguous subsets of data may better enable vectorization."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:118
msgid "For recursive computations, most of the work is towards the leaves, so the solution is to treat subtrees as a groups as shown in the following figure."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:127
msgid "Agglomeration of a recursive computation |image1|"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:168
msgid "image1"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:168
msgid ".. image:: main/tbb_userguide/design_patterns/Images/image003a.jpg"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:130
msgid "Often such an agglomeration is achieved by recursing serially once some threshold is reached. For example, a recursive sort might solve sub-problems in parallel only if they are above a certain threshold size."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst
msgid "Reference"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:142
msgid "Ian Foster introduced the term \"agglomeration\" in his book Designing and Building Parallel Programs http://www.mcs.anl.gov/~itf/dbpp. There agglomeration is part of a four step **PCAM** design method:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:147
msgid "**P**\\ artitioning - break the program into the smallest tasks possible."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:151
msgid "**C**\\ ommunication – figure out what communication is required between tasks. When using oneTBB, communication is usually cache line transfers. Though they are automatic, understanding which ones happen between tasks helps guide the agglomeration step."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:157
msgid "**A**\\ gglomeration – combine tasks into larger tasks. His book has an extensive list of considerations that is worth reading."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Agglomeration.rst:161
msgid "**M**\\ apping – map tasks onto processors. The oneTBB task scheduler does this step for you."
msgstr ""
