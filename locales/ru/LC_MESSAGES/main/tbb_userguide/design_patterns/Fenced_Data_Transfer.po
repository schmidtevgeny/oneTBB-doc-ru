# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 14:15+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:4
msgid "Fenced Data Transfer"
msgstr "Огражденная передача данных"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Problem"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:13
msgid "Write a message to memory and have another processor read it on hardware that does not have a sequentially consistent memory model."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Context"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:23
msgid "The problem normally arises only when unsynchronized threads concurrently act on a memory location, or are using reads and writes to create synchronization. High level synchronization constructs normally include mechanisms that prevent unwanted reordering."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:29
msgid "Modern hardware and compilers can reorder memory operations in a way that preserves the order of a thread's operation from its viewpoint, but not as observed by other threads. A serial common idiom is to write a message and mark it as ready to ready as shown in the following code:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:39
msgid ""
"bool Ready;\n"
"std::string Message;\n"
"\n"
"\n"
"void Send( const std::string& src ) {. // Executed by thread 1\n"
"   Message=src;\n"
"   Ready = true;\n"
"}\n"
"\n"
"\n"
"bool Receive( std::string& dst ) {    // Executed by thread 2\n"
"   bool result = Ready;\n"
"   if( result ) dst=Message;\n"
"   return result;              // Return true if message was received.\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:56
msgid "Two key assumptions of the code are:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:59
msgid "``Ready`` does not become true until ``Message`` is written."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:62
msgid "``Message`` is not read until ``Ready`` becomes true."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:65
msgid "These assumptions are trivially true on uniprocessor hardware. However, they may break on multiprocessor hardware. Reordering by the hardware or compiler can cause the sender's writes to appear out of order to the receiver (thus breaking condition a) or the receiver's reads to appear out of order (thus breaking condition b)."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Forces"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:78
msgid "Creating synchronization via raw reads and writes."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Solution"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:87
msgid "Change the flag from ``bool`` to ``std::atomic<bool>`` for the flag that indicates when the message is ready. Here is the previous example with modifications."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:95
msgid ""
"std::atomic<bool> Ready;\n"
"std::string Message;\n"
"\n"
"\n"
"void Send( const std::string& src ) {. // Executed by thread 1\n"
"   Message=src;\n"
"   Ready.store(true, std::memory_order_release);\n"
"}\n"
"\n"
"\n"
"bool Receive( std::string& dst ) {    // Executed by thread 2\n"
"   bool result = Ready.load(std::memory_order_acquire);\n"
"   if( result ) dst=Message;\n"
"   return result;              // Return true if message was received.\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:112
msgid "A write to a ``std::atomic`` value has *release* semantics, which means that all of its prior writes will be seen before the releasing write. A read from ``std::atomic`` value has *acquire* semantics, which means that all of its subsequent reads will happen after the acquiring read. The implementation of ``std::atomic`` ensures that both the compiler and the hardware observe these ordering constraints."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Variations"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:127
msgid "Higher level synchronization constructs normally include the necessary *acquire* and *release* fences. For example, mutexes are normally implemented such that acquisition of a lock has *acquire* semantics and release of a lock has *release* semantics. Thus a thread that acquires a lock on a mutex always sees any memory writes done by another thread before it released a lock on that mutex."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Non Solutions"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:141
msgid "Mistaken solutions are so often proposed that it is worth understanding why they are wrong."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:145
msgid "One common mistake is to assume that declaring the flag with the ``volatile`` keyword solves the problem. Though the ``volatile`` keyword forces a write to happen immediately, it generally has no effect on the visible ordering of that write with respect to other memory operations."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:152
msgid "Another mistake is to assume that conditionally executed code cannot happen before the condition is tested. However, the compiler or hardware may speculatively hoist the conditional code above the condition."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:158
msgid "Similarly, it is a mistake to assume that a processor cannot read the target of a pointer before reading the pointer. A modern processor does not read individual values from main memory. It reads cache lines. The target of a pointer may be in a cache line that has already been read before the pointer was read, thus giving the appearance that the processor presciently read the pointer target."
msgstr ""
