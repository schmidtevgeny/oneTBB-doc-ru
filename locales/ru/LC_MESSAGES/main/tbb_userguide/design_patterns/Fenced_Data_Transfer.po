# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-05-02 21:57+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:4
msgid "Fenced Data Transfer"
msgstr "Огражденная передача данных"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Problem"
msgstr "Проблема"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:13
msgid "Write a message to memory and have another processor read it on hardware that does not have a sequentially consistent memory model."
msgstr "Запиши сообщение в память и попроси другой процессор прочитать его на оборудовании, которое не имеет последовательной согласованной модели памяти."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Context"
msgstr "Контекст"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:23
msgid "The problem normally arises only when unsynchronized threads concurrently act on a memory location, or are using reads and writes to create synchronization. High level synchronization constructs normally include mechanisms that prevent unwanted reordering."
msgstr "Обычно проблема возникает только тогда, когда несинхронизированные потоки одновременно действуют на участок памяти или используют чтение и запись для создания синхронизации. Высокоуровневые конструкции синхронизации обычно включают механизмы, которые предотвращают нежелательное переупорядочивание."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:29
msgid "Modern hardware and compilers can reorder memory operations in a way that preserves the order of a thread's operation from its viewpoint, but not as observed by other threads. A serial common idiom is to write a message and mark it as ready to ready as shown in the following code:"
msgstr "Современные аппаратные средства и компиляторы могут переупорядочивать операции с памятью таким образом, что сохраняется порядок работы потока с его точки зрения, но не так, как его наблюдают другие потоки. Последовательная распространенная идиома заключается в том, чтобы написать сообщение и пометить его как готовое, как показано в следующем коде:"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:39
msgid ""
"bool Ready;\n"
"std::string Message;\n"
"\n"
"\n"
"void Send( const std::string& src ) {. // Executed by thread 1\n"
"   Message=src;\n"
"   Ready = true;\n"
"}\n"
"\n"
"\n"
"bool Receive( std::string& dst ) {    // Executed by thread 2\n"
"   bool result = Ready;\n"
"   if( result ) dst=Message;\n"
"   return result;              // Return true if message was received.\n"
"}"
msgstr ""
"bool Ready;\n"
"std::string Message;\n"
"\n"
"\n"
"void Send( const std::string& src ) { // Выполняется потоком 1\n"
"   Message=src;\n"
"   Ready = true;\n"
"}\n"
"\n"
"\n"
"bool Receive( std::string& dst ) {    // Выполняется потоком 2\n"
"   bool result = Ready;\n"
"   if( result ) dst=Message;\n"
"   return result;              // Возвращает true, если сообщение было получено.\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:56
msgid "Two key assumptions of the code are:"
msgstr "Два ключевых предположения кода таковы:"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:59
msgid "``Ready`` does not become true until ``Message`` is written."
msgstr "``Ready`` не становится истиной, пока ``Message`` не будет записано."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:62
msgid "``Message`` is not read until ``Ready`` becomes true."
msgstr "``Message`` не считывается до тех пор, пока ``Ready`` не станет истиной."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:65
msgid "These assumptions are trivially true on uniprocessor hardware. However, they may break on multiprocessor hardware. Reordering by the hardware or compiler can cause the sender's writes to appear out of order to the receiver (thus breaking condition a) or the receiver's reads to appear out of order (thus breaking condition b)."
msgstr "Эти предположения тривиально верны на однопроцессорном оборудовании. Однако они могут нарушаться на многопроцессорном оборудовании. Переупорядочивание аппаратуры или компилятора может привести к тому, что записи отправителя будут выглядеть для получателя не по порядку (тем самым нарушая условие а) или чтения получателя будут выглядеть не по порядку (тем самым нарушая условие б)."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Forces"
msgstr "Форсы"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:78
msgid "Creating synchronization via raw reads and writes."
msgstr "Создание синхронизации через необработанные чтения и записи."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Solution"
msgstr "Решение"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:87
msgid "Change the flag from ``bool`` to ``std::atomic<bool>`` for the flag that indicates when the message is ready. Here is the previous example with modifications."
msgstr "Измени флаг с ``bool`` на ``std::atomic<bool>`` для флага, который указывает, когда сообщение готово. Вот предыдущий пример с изменениями."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:95
msgid ""
"std::atomic<bool> Ready;\n"
"std::string Message;\n"
"\n"
"\n"
"void Send( const std::string& src ) {. // Executed by thread 1\n"
"   Message=src;\n"
"   Ready.store(true, std::memory_order_release);\n"
"}\n"
"\n"
"\n"
"bool Receive( std::string& dst ) {    // Executed by thread 2\n"
"   bool result = Ready.load(std::memory_order_acquire);\n"
"   if( result ) dst=Message;\n"
"   return result;              // Return true if message was received.\n"
"}"
msgstr ""
"std::atomic<bool> Ready;\n"
"std::string Message;\n"
"\n"
"\n"
"void Send( const std::string& src ) { // Выполняется потоком 1\n"
"   Message=src;\n"
"   Ready.store(true, std::memory_order_release);\n"
"}\n"
"\n"
"\n"
"bool Receive( std::string& dst ) {    // Выполняется потоком 2\n"
"   bool result = Ready.load(std::memory_order_acquire);\n"
"   if( result ) dst=Message;\n"
"   return result;              // Возвращает true, если сообщение было получено.\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:112
msgid "A write to a ``std::atomic`` value has *release* semantics, which means that all of its prior writes will be seen before the releasing write. A read from ``std::atomic`` value has *acquire* semantics, which means that all of its subsequent reads will happen after the acquiring read. The implementation of ``std::atomic`` ensures that both the compiler and the hardware observe these ordering constraints."
msgstr "Запись в значение ``std::atomic`` имеет семантику *release*, что означает, что все его предыдущие записи будут видны до освобождающей записи. Чтение из значения ``std::atomic`` имеет семантику *acquire*, что означает, что все его последующие чтения будут происходить после приобретающего чтения. Реализация ``std::atomic`` гарантирует, что и компилятор, и аппаратное обеспечение соблюдают эти ограничения упорядочивания."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Variations"
msgstr "Вариации"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:127
msgid "Higher level synchronization constructs normally include the necessary *acquire* and *release* fences. For example, mutexes are normally implemented such that acquisition of a lock has *acquire* semantics and release of a lock has *release* semantics. Thus a thread that acquires a lock on a mutex always sees any memory writes done by another thread before it released a lock on that mutex."
msgstr "Конструкции синхронизации более высокого уровня обычно включают в себя необходимые ограждения *acquire* и *release*. Например, мьютексы обычно реализуются таким образом, что получение блокировки имеет семантику *acquire*, а освобождение блокировки - семантику *release*. Таким образом, поток, который приобретает блокировку на мьютексе, всегда видит все записи в память, сделанные другим потоком до того, как он освободил блокировку на этом мьютексе."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst
msgid "Non Solutions"
msgstr "Нерациональные решения"

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:141
msgid "Mistaken solutions are so often proposed that it is worth understanding why they are wrong."
msgstr "Ошибочные решения предлагаются так часто, что стоит понять, почему они ошибочны."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:145
msgid "One common mistake is to assume that declaring the flag with the ``volatile`` keyword solves the problem. Though the ``volatile`` keyword forces a write to happen immediately, it generally has no effect on the visible ordering of that write with respect to other memory operations."
msgstr "Одна из распространенных ошибок - считать, что объявление флага с ключевым словом ``volatile`` решает проблему. Хотя ключевое слово ``volatile`` заставляет запись происходить немедленно, оно обычно не влияет на видимое упорядочивание этой записи относительно других операций с памятью."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:152
msgid "Another mistake is to assume that conditionally executed code cannot happen before the condition is tested. However, the compiler or hardware may speculatively hoist the conditional code above the condition."
msgstr "Еще одна ошибка - предполагать, что условно выполняемый код не может произойти до того, как условие будет проверено. Однако компилятор или аппаратное обеспечение могут спекулятивно поднять условный код выше условия."

#: ../../oneTBB/doc/main/tbb_userguide/design_patterns/Fenced_Data_Transfer.rst:158
msgid "Similarly, it is a mistake to assume that a processor cannot read the target of a pointer before reading the pointer. A modern processor does not read individual values from main memory. It reads cache lines. The target of a pointer may be in a cache line that has already been read before the pointer was read, thus giving the appearance that the processor presciently read the pointer target."
msgstr "Аналогично, ошибкой является предположение, что процессор не может прочитать цель указателя до чтения указателя. Современный процессор не читает отдельные значения из основной памяти. Он считывает линии кэша. Цель указателя может находиться в строке кэша, которая уже была прочитана до того, как указатель был прочитан, что создаст впечатление, что процессор прозорливо прочитал цель указателя."
