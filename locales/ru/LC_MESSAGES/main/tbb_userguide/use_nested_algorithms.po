# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: oneTBB \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_algorithms.rst:4
msgid "Use Nested Algorithms to Increase Scalability"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_algorithms.rst:7
msgid ""
"One powerful way to increase the scalability of a flow graph is to nest "
"other parallel algorithms inside of node bodies. Doing so, you can use a "
"flow graph as a coordination language, expressing the most coarse-grained"
" parallelism at the level of the graph, with finer grained parallelism "
"nested within."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_algorithms.rst:14
msgid ""
"In the example below, five nodes are created: an ``input_node``, "
"``matrix_source``, that reads a sequence of matrices from a file, two "
"``function_nodes``, ``n1`` and ``n2``, that receive these matrices and "
"generate two new matrices by applying a function to each element, and two"
" final ``function_nodes``, ``n1_sink`` and ``n2_sink``, that process "
"these resulting matrices. The ``matrix_source`` is connected to both "
"``n1`` and ``n2``. The node ``n1`` is connected to ``n1_sink``, and "
"``n2`` is connected to ``n2_sink``. In the lambda expressions for ``n1`` "
"and ``n2``, a ``parallel_for`` is used to apply the functions to the "
"elements of the matrix in parallel. The functions ``read_next_matrix``, "
"``f1``, ``f2``, ``consume_f1`` and ``consume_f2`` are not provided below."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_algorithms.rst:30
msgid ""
"graph g;\n"
"input_node< double * > matrix_source( g, [&]( oneapi::tbb::flow_control "
"&fc ) -> double* {\n"
"  double *a = read_next_matrix();\n"
"  if ( a ) {\n"
"    return a;\n"
"  } else {\n"
"    fc.stop();\n"
"    return nullptr;\n"
"  }\n"
"} );\n"
"function_node< double *, double * > n1( g, unlimited, [&]( double *a ) ->"
" double * {\n"
"  double *b = new double[N];\n"
"  parallel_for( 0, N, [&](int i) {\n"
"    b[i] = f1(a[i]);\n"
"  } );\n"
"  return b;\n"
"} );\n"
"function_node< double *, double * > n2( g, unlimited, [&]( double *a ) ->"
" double * {\n"
"  double *b = new double[N];\n"
"  parallel_for( 0, N, [&](int i) {\n"
"    b[i] = f2(a[i]);\n"
"  } );\n"
"  return b;\n"
"} );\n"
"function_node< double *, double * > n1_sink( g, unlimited,\n"
"  []( double *b ) -> double * {\n"
"    return consume_f1(b);\n"
"} );\n"
"function_node< double *, double * > n2_sink( g, unlimited,\n"
"  []( double *b ) -> double * {\n"
"    return consume_f2(b);\n"
"} );\n"
"make_edge( matrix_source, n1 );\n"
"make_edge( matrix_source, n2 );\n"
"make_edge( n1, n1_sink );\n"
"make_edge( n2, n2_sink );\n"
"matrix_source.activate();\n"
"g.wait_for_all();"
msgstr ""

