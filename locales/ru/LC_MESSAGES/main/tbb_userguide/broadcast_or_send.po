# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 14:19+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:4
msgid "Sending to One or Multiple Successors"
msgstr "Отправка одному или нескольким преемникам"

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:7
msgid "An important characteristic of the predefined nodes is whether they push their output to a single successor or broadcast to all successors. The following predefined nodes push messages to a single successor:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:12
msgid "buffer_node"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:13
msgid "queue_node"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:14
msgid "priority_queue_node"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:15
msgid "sequencer_node"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:18
msgid "Other nodes push messages to all successors that will accept them."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:21
msgid "The nodes that push to only a single successor are all buffer nodes. Their purpose is to hold messages temporarily, until they are consumed downstream. Consider the example below:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:29
msgid ""
"void use_buffer_and_two_nodes() {\n"
"  graph g;\n"
"\n"
"\n"
"  function_node< int, int, rejecting > f1( g, 1, []( int i ) -> int {\n"
"    spin_for(0.1);\n"
"    cout << \"f1 consuming \" << i << \"\\n\";\n"
"    return i;\n"
"  } );\n"
"\n"
"\n"
"  function_node< int, int, rejecting > f2( g, 1, []( int i ) -> int {\n"
"    spin_for(0.2);\n"
"    cout << \"f2 consuming \" << i << \"\\n\";\n"
"    return i;\n"
"  } );\n"
"\n"
"\n"
"  priority_queue_node< int > q(g);\n"
"\n"
"\n"
"  make_edge( q, f1 );\n"
"  make_edge( q, f2 );\n"
"  for ( int i = 10; i > 0; --i ) {\n"
"    q.try_put( i );\n"
"  }\n"
"  g.wait_for_all();\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:59
msgid "First, function_nodes by default queue up the messages they receive at their input. To make a priority_queue_node work properly with a function_node, the example above constructs its function_nodes with its buffer policy set to rejecting. So, f1 and f2 do not internally buffer incoming messages, but instead rely on upstream buffering in the priority_queue_node."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:67
msgid "In the above example, each message buffered by the priority_queue_node is sent to either f1 or f2, but not both."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:71
msgid "Let's consider the alternative behavior; that is; what if the priority_queue_node broadcasts to all successors. What if some, but not all, nodes accept a message? Should the message be buffered until all nodes accept it, or be only delivered to the accepting subset? If the node continues to buffer the message, should it eventually deliver the messages in the same order to all nodes or in the current priority order at the time the node accepts the next message? For example, assume a priority_queue_node only contains \"9\" when a successor node, f1, accepts \"9\" but another successor node, f2, rejects it. Later a value \"100\" arrives and f2 is available to accept messages. Should f2 receive \"9\" next or \"100\", which has a higher priority? In any case, trying to ensure that all successors receive each message creates a garbage collection problem and complicates reasoning. Therefore, these buffering nodes push each message to only one successor. And, you can use this characteristic to create useful graph structures such as the one shown in the graph above, where each message will be processed in priority order, by either f1 or f2."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:90
msgid "But what if you really do want both f1 and f2 to receive all of the values, and in priority order? You can easily create this behavior by creating one priority_queue_node for each function_node, and pushing each value to both queues through a broadcast_node, as shown below:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:99
msgid ""
"graph g;\n"
"\n"
"\n"
"function_node< int, int, rejecting > f1( g, 1, []( int i ) -> int {\n"
"  spin_for(0.1);\n"
"  cout << \"f1 consuming \" << i << \"\\n\";\n"
"  return i;\n"
"} );\n"
"\n"
"\n"
"function_node< int, int, rejecting > f2( g, 1, []( int i ) -> int {\n"
"  spin_for(0.2);\n"
"  cout << \"f2 consuming \" << i << \"\\n\";\n"
"  return i;\n"
"} );\n"
"\n"
"\n"
"priority_queue_node< int > q1(g);\n"
"priority_queue_node< int > q2(g);\n"
"broadcast_node< int > b(g);\n"
"\n"
"\n"
"make_edge( b, q1 );\n"
"make_edge( b, q2 );\n"
"make_edge( q1, f1 );\n"
"make_edge( q2, f2 );\n"
"for ( int i = 10; i > 0; --i ) {\n"
"  b.try_put( i );\n"
"}\n"
"g.wait_for_all();"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/broadcast_or_send.rst:131
msgid "So, when connecting a node in your graph to multiple successors, be sure to understand whether the output will broadcast to all of the successors, or just a single successor."
msgstr ""
