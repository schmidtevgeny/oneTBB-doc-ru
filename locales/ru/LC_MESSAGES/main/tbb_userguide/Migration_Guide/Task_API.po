# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-05-02 21:16+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:4
msgid "Migrating from low-level task API"
msgstr "Переход от низкоуровневого API задач"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:6
msgid "The low-level task API of Intel(R) Threading Building Blocks (TBB) was considered complex and hence error-prone, which was the primary reason it had been removed from oneAPI Threading Building Blocks (oneTBB). This guide helps with the migration from TBB to oneTBB for the use cases where low-level task API is used."
msgstr "Низкоуровневый API задач в Intel(R) Threading Building Blocks (TBB) считался сложным и, следовательно, подверженным ошибкам, что стало основной причиной его удаления из oneAPI Threading Building Blocks (oneTBB). Это руководство поможет в миграции с TBB на oneTBB для тех случаев использования, когда применяется низкоуровневый API задач."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:12
msgid "Spawning of individual tasks"
msgstr "Размножение отдельных задач"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:13
msgid "For most use cases, the spawning of individual tasks can be replaced with the use of either ``oneapi::tbb::task_group`` or ``oneapi::tbb::parallel_invoke``."
msgstr "Для большинства случаев использования порождение отдельных задач можно заменить использованием ``oneapi::tbb::task_group`` или ``oneapi::tbb::parallel_invoke``."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:16
msgid "For example, ``RootTask``, ``ChildTask1``, and ``ChildTask2`` are the user-side functors that inherit ``tbb::task`` and implement its interface. Then spawning of ``ChildTask1`` and ``ChildTask2`` tasks that can execute in parallel with each other and waiting on the ``RootTask`` is implemented as:"
msgstr "Например, ``RootTask``, ``ChildTask1`` и ``ChildTask2`` - это пользовательские функторы, которые наследуют ``tbb::task`` и реализуют его интерфейс. Тогда порождение задач ``ChildTask1`` и ``ChildTask2``, которые могут выполняться параллельно друг с другом и ожидать ``RootTask``, реализуется следующим образом:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:21
msgid ""
"#include <tbb/task.h>\n"
"\n"
"int main() {\n"
"    // Assuming RootTask, ChildTask1, and ChildTask2 are defined.\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{};\n"
"\n"
"    ChildTask1& child1 = *new(root.allocate_child()) ChildTask1{/*params*/};\n"
"    ChildTask2& child2 = *new(root.allocate_child()) ChildTask2{/*params*/};\n"
"\n"
"    root.set_ref_count(3);\n"
"\n"
"    tbb::task::spawn(child1);\n"
"    tbb::task::spawn(child2);\n"
"\n"
"    root.wait_for_all();\n"
"}"
msgstr ""
"#include <tbb/task.h>\n"
"\n"
"int main() {\n"
"    // Предположим, что определены RootTask, ChildTask1 и ChildTask2.\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{};\n"
"\n"
"    ChildTask1& child1 = *new(root.allocate_child()) ChildTask1{/*params*/};\n"
"    ChildTask2& child2 = *new(root.allocate_child()) ChildTask2{/*params*/};\n"
"\n"
"    root.set_ref_count(3);\n"
"\n"
"    tbb::task::spawn(child1);\n"
"    tbb::task::spawn(child2);\n"
"\n"
"    root.wait_for_all();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:42
msgid "Using ``oneapi::tbb::task_group``"
msgstr "Использование ``oneapi::tbb::task_group``"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:43
msgid "The code above can be rewritten using ``oneapi::tbb::task_group``:"
msgstr "Код выше можно переписать, используя ``oneapi::tbb::task_group``:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:45
msgid ""
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"int main() {\n"
"    // Assuming ChildTask1, and ChildTask2 are defined.\n"
"    oneapi::tbb::task_group tg;\n"
"    tg.run(ChildTask1{/*params*/});\n"
"    tg.run(ChildTask2{/*params*/});\n"
"    tg.wait();\n"
"}"
msgstr ""
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"int main() {\n"
"    // Предположим, что определены ChildTask1 и ChildTask2.\n"
"    oneapi::tbb::task_group tg;\n"
"    tg.run(ChildTask1{/*params*/});\n"
"    tg.run(ChildTask2{/*params*/});\n"
"    tg.wait();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:57
msgid "The code looks more concise now. It also enables lambda functions and does not require you to implement ``tbb::task`` interface that overrides the ``tbb::task* tbb::task::execute()`` virtual method. With this new approach, you work with functors in a C++-standard way by implementing ``void operator() const``:"
msgstr "Теперь код выглядит более лаконичным. Он также включает лямбда-функции и не требует от тебя реализации интерфейса ``tbb::task``, который переопределяет виртуальный метод ``tbb::task* tbb::task::execute()``. С помощью этого нового подхода ты работаешь с функторами стандартным для C++ способом, реализуя ``void operator() const``:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:62
msgid ""
"struct Functor {\n"
"    // Member to be called when object of this type are passed into\n"
"    // oneapi::tbb::task_group::run() method\n"
"    void operator()() const {}\n"
"};"
msgstr ""
"struct Functor {\n"
"    // Member to be called when object of this type are passed into\n"
"    // oneapi::tbb::task_group::run() method\n"
"    void operator()() const {}\n"
"};"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:72
msgid "Using ``oneapi::tbb::parallel_invoke``"
msgstr "Использование ``oneapi::tbb::parallel_invoke``"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:73
msgid "It is also possible to use ``oneapi::tbb::parallel_invoke`` to rewrite the original code and make it even more concise:"
msgstr "Также можно использовать ``oneapi::tbb::parallel_invoke``, чтобы переписать исходный код и сделать его еще более лаконичным:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:76
msgid ""
"#include <oneapi/tbb/parallel_invoke.h>\n"
"\n"
"int main() {\n"
"    // Assuming ChildTask1, and ChildTask2 are defined.\n"
"    oneapi::tbb::parallel_invoke(\n"
"        ChildTask1{/*params*/},\n"
"        ChildTask2{/*params*/}\n"
"    );\n"
"}"
msgstr ""
"#include <oneapi/tbb/parallel_invoke.h>\n"
"\n"
"int main() {\n"
"    // Предположим, что определены ChildTask1 и ChildTask2.\n"
"    oneapi::tbb::parallel_invoke(\n"
"        ChildTask1{/*params*/},\n"
"        ChildTask2{/*params*/}\n"
"    );\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:90
msgid "Adding more work during task execution"
msgstr "Добавление дополнительной работы во время выполнения задания"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:91
msgid "``oneapi::tbb::parallel_invoke`` follows a blocking style of programming, which means that it completes only when all functors passed to the parallel pattern complete their execution."
msgstr "``oneapi::tbb::parallel_invoke`` следует блокирующему стилю программирования, что означает, что он завершается только тогда, когда все функторы, переданные параллельному паттерну, завершают свое выполнение."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:94
msgid "In TBB, cases when the amount of work is not known in advance and the work needs to be added during the execution of a parallel algorithm were mostly covered by ``tbb::parallel_do`` high-level parallel pattern. The ``tbb::parallel_do`` algorithm logic may be implemented using the task API as:"
msgstr "В TBB случаи, когда количество работы не известно заранее и работу нужно добавить во время выполнения параллельного алгоритма, в основном покрывались высокоуровневым параллельным паттерном ``tbb::parallel_do``. Логика алгоритма ``tbb::parallel_do`` может быть реализована с помощью API задач как:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:98
msgid ""
"#include <cstddef>\n"
"#include <vector>\n"
"#include <tbb/task.h>\n"
"\n"
"// Assuming RootTask and OtherWork are defined and implement tbb::task interface.\n"
"\n"
"struct Task : public tbb::task {\n"
"    Task(tbb::task& root, int i)\n"
"        : m_root(root), m_i(i)\n"
"    {}\n"
"\n"
"    tbb::task* execute() override {\n"
"        // ... do some work for item m_i ...\n"
"\n"
"        if (add_more_parallel_work) {\n"
"            tbb::task& child = *new(m_root.allocate_child()) OtherWork;\n"
"            tbb::task::spawn(child);\n"
"        }\n"
"        return nullptr;\n"
"    }\n"
"\n"
"    tbb::task& m_root;\n"
"    int m_i;\n"
"};\n"
"\n"
"int main() {\n"
"    std::vector<int> items = { 0, 1, 2, 3, 4, 5, 6, 7 };\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{/*params*/};\n"
"\n"
"    root.set_ref_count(items.size() + 1);\n"
"\n"
"    for (std::size_t i = 0; i < items.size(); ++i) {\n"
"        Task& task = *new(root.allocate_child()) Task(root, items[i]);\n"
"        tbb::task::spawn(task);\n"
"    }\n"
"\n"
"    root.wait_for_all();\n"
"    return 0;\n"
"}"
msgstr ""
"#include <cstddef>\n"
"#include <vector>\n"
"#include <tbb/task.h>\n"
"\n"
"// Предполагается, что RootTask и OtherWork определены и реализуют tbb::task interface.\n"
"\n"
"struct Task : public tbb::task {\n"
"    Task(tbb::task& root, int i)\n"
"        : m_root(root), m_i(i)\n"
"    {}\n"
"\n"
"    tbb::task* execute() override {\n"
"        // ... выполнять работу за объект m_i ...\n"
"\n"
"        if (add_more_parallel_work) {\n"
"            tbb::task& child = *new(m_root.allocate_child()) OtherWork;\n"
"            tbb::task::spawn(child);\n"
"        }\n"
"        return nullptr;\n"
"    }\n"
"\n"
"    tbb::task& m_root;\n"
"    int m_i;\n"
"};\n"
"\n"
"int main() {\n"
"    std::vector<int> items = { 0, 1, 2, 3, 4, 5, 6, 7 };\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{/*params*/};\n"
"\n"
"    root.set_ref_count(items.size() + 1);\n"
"\n"
"    for (std::size_t i = 0; i < items.size(); ++i) {\n"
"        Task& task = *new(root.allocate_child()) Task(root, items[i]);\n"
"        tbb::task::spawn(task);\n"
"    }\n"
"\n"
"    root.wait_for_all();\n"
"    return 0;\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:140
msgid "In oneTBB ``tbb::parallel_do`` interface was removed. Instead, the functionality of adding new work was included into the ``oneapi::tbb::parallel_for_each`` interface."
msgstr "В oneTBB интерфейс ``tbb::parallel_do`` был удален. Вместо этого функциональность добавления новой работы была включена в интерфейс ``oneapi::tbb::parallel_for_each``."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:143
msgid "The previous use case can be rewritten in oneTBB as follows:"
msgstr "Предыдущий вариант использования может быть переписан в OneTBB следующим образом:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:145
msgid ""
"#include <vector>\n"
"#include <oneapi/tbb/parallel_for_each.h>\n"
"\n"
"int main() {\n"
"    std::vector<int> items = { 0, 1, 2, 3, 4, 5, 6, 7 };\n"
"\n"
"    oneapi::tbb::parallel_for_each(\n"
"        items.begin(), items.end(),\n"
"        [](int& i, tbb::feeder<int>& feeder) {\n"
"\n"
"            // ... do some work for item i ...\n"
"\n"
"            if (add_more_parallel_work)\n"
"                feeder.add(i);\n"
"        }\n"
"    );\n"
"}"
msgstr ""
"#include <vector>\n"
"#include <oneapi/tbb/parallel_for_each.h>\n"
"\n"
"int main() {\n"
"    std::vector<int> items = { 0, 1, 2, 3, 4, 5, 6, 7 };\n"
"\n"
"    oneapi::tbb::parallel_for_each(\n"
"        items.begin(), items.end(),\n"
"        [](int& i, tbb::feeder<int>& feeder) {\n"
"\n"
"            // ... выполнять работу за объект i ...\n"
"\n"
"            if (add_more_parallel_work)\n"
"                feeder.add(i);\n"
"        }\n"
"    );\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:165
msgid "Since both TBB and oneTBB support nested expressions, you can run additional functors from within an already running functor."
msgstr "Поскольку и TBB, и oneTBB поддерживают вложенные выражения, ты можешь запускать дополнительные функторы изнутри уже запущенного функтора."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:168
msgid "The previous use case can be rewritten using ``oneapi::tbb::task_group`` as:"
msgstr "Предыдущий вариант использования можно переписать, используя ``oneapi::tbb::task_group`` как:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:170
msgid ""
"#include <cstddef>\n"
"#include <vector>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"int main() {\n"
"    std::vector<int> items = { 0, 1, 2, 3, 4, 5, 6, 7 };\n"
"\n"
"    oneapi::tbb::task_group tg;\n"
"    for (std::size_t i = 0; i < items.size(); ++i) {\n"
"        tg.run([&i = items[i], &tg] {\n"
"\n"
"            // ... do some work for item i ...\n"
"\n"
"            if (add_more_parallel_work)\n"
"                // Assuming OtherWork is defined.\n"
"                tg.run(OtherWork{});\n"
"\n"
"        });\n"
"    }\n"
"    tg.wait();\n"
"}"
msgstr ""
"#include <cstddef>\n"
"#include <vector>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"int main() {\n"
"    std::vector<int> items = { 0, 1, 2, 3, 4, 5, 6, 7 };\n"
"\n"
"    oneapi::tbb::task_group tg;\n"
"    for (std::size_t i = 0; i < items.size(); ++i) {\n"
"        tg.run([&i = items[i], &tg] {\n"
"\n"
"            // ... do some work for item i ...\n"
"\n"
"            if (add_more_parallel_work)\n"
"                // Assuming OtherWork is defined.\n"
"                tg.run(OtherWork{});\n"
"\n"
"        });\n"
"    }\n"
"    tg.wait();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:196
msgid "Task recycling"
msgstr "Повтор заданий"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:197
msgid "You can re-run the functor by passing ``*this`` to the ``oneapi::tbb::task_group::run()`` method. The functor will be copied in this case. However, its state can be shared among instances:"
msgstr "Ты можешь повторно запустить функтор, передав ``*this`` методу ``oneapi::tbb::task_group::run()``. Функтор в этом случае будет скопирован. Однако его состояние может быть разделено между экземплярами:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:200
msgid ""
"#include <memory>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"struct SharedStateFunctor {\n"
"    std::shared_ptr<Data> m_shared_data;\n"
"    oneapi::tbb::task_group& m_task_group;\n"
"\n"
"    void operator()() const {\n"
"        // do some work processing m_shared_data\n"
"\n"
"        if (has_more_work)\n"
"            m_task_group.run(*this);\n"
"\n"
"        // Note that this might be concurrently accessing m_shared_data already\n"
"    }\n"
"};\n"
"\n"
"int main() {\n"
"    // Assuming Data is defined.\n"
"    std::shared_ptr<Data> data = std::make_shared<Data>(/*params*/);\n"
"    oneapi::tbb::task_group tg;\n"
"    tg.run(SharedStateFunctor{data, tg});\n"
"    tg.wait();\n"
"}"
msgstr ""
"#include <memory>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"struct SharedStateFunctor {\n"
"    std::shared_ptr<Data> m_shared_data;\n"
"    oneapi::tbb::task_group& m_task_group;\n"
"\n"
"    void operator()() const {\n"
"        // do some work processing m_shared_data\n"
"\n"
"        if (has_more_work)\n"
"            m_task_group.run(*this);\n"
"\n"
"        // Note that this might be concurrently accessing m_shared_data already\n"
"    }\n"
"};\n"
"\n"
"int main() {\n"
"    // Assuming Data is defined.\n"
"    std::shared_ptr<Data> data = std::make_shared<Data>(/*params*/);\n"
"    oneapi::tbb::task_group tg;\n"
"    tg.run(SharedStateFunctor{data, tg});\n"
"    tg.wait();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:227
msgid "Such patterns are particularly useful when the work within a functor is not completed but there is a need for the task scheduler to react to outer circumstances, such as cancellation of group execution. To avoid issues with concurrent access, it is recommended to submit it for re-execution as the last step:"
msgstr "Такие паттерны особенно полезны в тех случаях, когда работа внутри функтора не завершена, но есть необходимость, чтобы планировщик задач реагировал на внешние обстоятельства, например, отмену выполнения группы. Чтобы избежать проблем с одновременным доступом, рекомендуется отправлять его на повторное выполнение в качестве последнего шага:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:232
msgid ""
"#include <memory>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"struct SharedStateFunctor {\n"
"    std::shared_ptr<Data> m_shared_data;\n"
"    oneapi::tbb::task_group& m_task_group;\n"
"\n"
"    void operator()() const {\n"
"        // do some work processing m_shared_data\n"
"\n"
"        if (need_to_yield) {\n"
"            m_task_group.run(*this);\n"
"            return;\n"
"        }\n"
"    }\n"
"};\n"
"\n"
"int main() {\n"
"    // Assuming Data is defined.\n"
"    std::shared_ptr<Data> data = std::make_shared<Data>(/*params*/);\n"
"    oneapi::tbb::task_group tg;\n"
"    tg.run(SharedStateFunctor{data, tg});\n"
"    tg.wait();\n"
"}"
msgstr ""
"#include <memory>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"struct SharedStateFunctor {\n"
"    std::shared_ptr<Data> m_shared_data;\n"
"    oneapi::tbb::task_group& m_task_group;\n"
"\n"
"    void operator()() const {\n"
"        // выполнить определенную обработку m_shared_data\n"
"\n"
"        if (need_to_yield) {\n"
"            m_task_group.run(*this);\n"
"            return;\n"
"        }\n"
"    }\n"
"};\n"
"\n"
"int main() {\n"
"    // Предполагается, что данные определены.\n"
"    std::shared_ptr<Data> data = std::make_shared<Data>(/*params*/);\n"
"    oneapi::tbb::task_group tg;\n"
"    tg.run(SharedStateFunctor{data, tg});\n"
"    tg.wait();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:261
msgid "Recycling as child or continuation"
msgstr "Повтор как ребенок или продолжение"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:262
msgid "In oneTBB this kind of recycling is done manually. You have to track when it is time to run the task:"
msgstr "В OneTBB такая переработка выполняется вручную. Ты должен отслеживать, когда наступает время выполнения задания:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:265
msgid ""
"#include <cstddef>\n"
"#include <vector>\n"
"#include <atomic>\n"
"#include <cassert>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"struct ContinuationTask {\n"
"    ContinuationTask(std::vector<int>& data, int& result)\n"
"        : m_data(data), m_result(result)\n"
"    {}\n"
"\n"
"    void operator()() const {\n"
"        for (const auto& item : m_data)\n"
"            m_result += item;\n"
"    }\n"
"\n"
"    std::vector<int>& m_data;\n"
"    int& m_result;\n"
"};\n"
"\n"
"struct ChildTask {\n"
"    ChildTask(std::vector<int>& data, int& result,\n"
"              std::atomic<std::size_t>& tasks_left, std::atomic<std::size_t>& tasks_done,\n"
"              oneapi::tbb::task_group& tg)\n"
"        : m_data(data), m_result(result), m_tasks_left(tasks_left), m_tasks_done(tasks_done), m_tg(tg)\n"
"    {}\n"
"\n"
"    void operator()() const {\n"
"        std::size_t index = --m_tasks_left;\n"
"        m_data[index] = produce_item_for(index);\n"
"        std::size_t done_num = ++m_tasks_done;\n"
"        if (index % 2 != 0) {\n"
"            // Recycling as child\n"
"            m_tg.run(*this);\n"
"            return;\n"
"        } else if (done_num == m_data.size()) {\n"
"            assert(m_tasks_left == 0);\n"
"            // Spawning a continuation that does reduction\n"
"            m_tg.run(ContinuationTask(m_data, m_result));\n"
"        }\n"
"    }\n"
"    std::vector<int>& m_data;\n"
"    int& m_result;\n"
"    std::atomic<std::size_t>& m_tasks_left;\n"
"    std::atomic<std::size_t>& m_tasks_done;\n"
"    oneapi::tbb::task_group& m_tg;\n"
"};\n"
"\n"
"\n"
"int main() {\n"
"    int result = 0;\n"
"    std::vector<int> items(10, 0);\n"
"    std::atomic<std::size_t> tasks_left{items.size()};\n"
"    std::atomic<std::size_t> tasks_done{0};\n"
"\n"
"    oneapi::tbb::task_group tg;\n"
"    for (std::size_t i = 0; i < items.size(); i+=2) {\n"
"        tg.run(ChildTask(items, result, tasks_left, tasks_done, tg));\n"
"    }\n"
"    tg.wait();\n"
"}"
msgstr ""
"#include <cstddef>\n"
"#include <vector>\n"
"#include <atomic>\n"
"#include <cassert>\n"
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"struct ContinuationTask {\n"
"    ContinuationTask(std::vector<int>& data, int& result)\n"
"        : m_data(data), m_result(result)\n"
"    {}\n"
"\n"
"    void operator()() const {\n"
"        for (const auto& item : m_data)\n"
"            m_result += item;\n"
"    }\n"
"\n"
"    std::vector<int>& m_data;\n"
"    int& m_result;\n"
"};\n"
"\n"
"struct ChildTask {\n"
"    ChildTask(std::vector<int>& data, int& result,\n"
"              std::atomic<std::size_t>& tasks_left, std::atomic<std::size_t>& tasks_done,\n"
"              oneapi::tbb::task_group& tg)\n"
"        : m_data(data), m_result(result), m_tasks_left(tasks_left), m_tasks_done(tasks_done), m_tg(tg)\n"
"    {}\n"
"\n"
"    void operator()() const {\n"
"        std::size_t index = --m_tasks_left;\n"
"        m_data[index] = produce_item_for(index);\n"
"        std::size_t done_num = ++m_tasks_done;\n"
"        if (index % 2 != 0) {\n"
"            // Обработка дочерних\n"
"            m_tg.run(*this);\n"
"            return;\n"
"        } else if (done_num == m_data.size()) {\n"
"            assert(m_tasks_left == 0);\n"
"            // Порождение продолжения, которое выполняет свертку\n"
"            m_tg.run(ContinuationTask(m_data, m_result));\n"
"        }\n"
"    }\n"
"    std::vector<int>& m_data;\n"
"    int& m_result;\n"
"    std::atomic<std::size_t>& m_tasks_left;\n"
"    std::atomic<std::size_t>& m_tasks_done;\n"
"    oneapi::tbb::task_group& m_tg;\n"
"};\n"
"\n"
"\n"
"int main() {\n"
"    int result = 0;\n"
"    std::vector<int> items(10, 0);\n"
"    std::atomic<std::size_t> tasks_left{items.size()};\n"
"    std::atomic<std::size_t> tasks_done{0};\n"
"\n"
"    oneapi::tbb::task_group tg;\n"
"    for (std::size_t i = 0; i < items.size(); i+=2) {\n"
"        tg.run(ChildTask(items, result, tasks_left, tasks_done, tg));\n"
"    }\n"
"    tg.wait();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:331
msgid "Scheduler Bypass"
msgstr "Обход планировщика"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:333
msgid "TBB ``task::execute()`` method can return a pointer to a task that can be executed next by the current thread. This might reduce scheduling overheads compared to direct ``spawn``. Similar to ``spawn``, the returned task is not guaranteed to be executed next by the current thread."
msgstr "Метод TBB ``task::execute()`` может возвращать указатель на задачу, которая может быть выполнена следующей текущим потоком. Это может снизить накладные расходы на планирование по сравнению с прямым ``spawn``. Как и в случае с ``spawn``, возвращенная задача не гарантируется, что она будет выполнена следующей текущим потоком."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:337
msgid ""
"#include <tbb/task.h>\n"
"\n"
"// Assuming OtherTask is defined.\n"
"\n"
"struct Task : tbb::task {\n"
"    task* execute(){\n"
"        // some work to do ...\n"
"\n"
"        auto* other_p = new(this->parent().allocate_child()) OtherTask{};\n"
"        this->parent().add_ref_count();\n"
"\n"
"        return other_p;\n"
"    }\n"
"};\n"
"\n"
"int main(){\n"
"    // Assuming RootTask is  defined.\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{};\n"
"\n"
"    Task& child = *new(root.allocate_child()) Task{/*params*/};\n"
"\n"
"    root.add_ref_count();\n"
"\n"
"    tbb::task_spawn(child);\n"
"\n"
"    root.wait_for_all();;\n"
"}"
msgstr ""
"#include <tbb/task.h>\n"
"\n"
"// Assuming OtherTask is defined.\n"
"\n"
"struct Task : tbb::task {\n"
"    task* execute(){\n"
"        // some work to do ...\n"
"\n"
"        auto* other_p = new(this->parent().allocate_child()) OtherTask{};\n"
"        this->parent().add_ref_count();\n"
"\n"
"        return other_p;\n"
"    }\n"
"};\n"
"\n"
"int main(){\n"
"    // Assuming RootTask is  defined.\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{};\n"
"\n"
"    Task& child = *new(root.allocate_child()) Task{/*params*/};\n"
"\n"
"    root.add_ref_count();\n"
"\n"
"    tbb::task_spawn(child);\n"
"\n"
"    root.wait_for_all();;\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:367
#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:423
msgid "In oneTBB, this can be done using ``oneapi::tbb::task_group``."
msgstr "В oneTBB это можно сделать с помощью ``oneapi::tbb::task_group``."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:369
msgid ""
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"// Assuming OtherTask is defined.\n"
"\n"
"int main(){\n"
"    oneapi::tbb::task_group tg;\n"
"\n"
"    tg.run([&tg](){\n"
"        //some work to do ...\n"
"\n"
"        return tg.defer(OtherTask{});\n"
"    });\n"
"\n"
"    tg.wait();\n"
"}"
msgstr ""
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"// Assuming OtherTask is defined.\n"
"\n"
"int main(){\n"
"    oneapi::tbb::task_group tg;\n"
"\n"
"    tg.run([&tg](){\n"
"        //some work to do ...\n"
"\n"
"        return tg.defer(OtherTask{});\n"
"    });\n"
"\n"
"    tg.wait();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:387
msgid "Here ``oneapi::tbb::task_group::defer`` adds a new task into the ``tg``. However, the task is not put into a queue of tasks ready for execution via ``oneapi::tbb::task_group::run``, but bypassed to the executing thread directly via function return value."
msgstr "Здесь ``oneapi::tbb::task_group::defer`` добавляет новую задачу в ``tg``. Однако задача не помещается в очередь задач, готовых к выполнению через ``oneapi::tbb::task_group::run``, а передается исполняющему потоку напрямую через возвращаемое значение функции."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:392
msgid "Deferred task creation"
msgstr "Отложенное создание задачи"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:393
msgid "The TBB low-level task API separates the task creation from the actual spawning. This separation allows to postpone the task spawning, while the parent task and final result production are blocked from premature leave. For example, ``RootTask``, ``ChildTask``, and ``CallBackTask`` are the user-side functors that inherit ``tbb::task`` and implement its interface. Then, blocking the ``RootTask`` from leaving prematurely and waiting on it is implemented as follows:"
msgstr "Низкоуровневый API задач TBB отделяет создание задачи от фактического порождения. Это разделение позволяет отложить порождение задачи, в то время как родительская задача и производство конечного результата блокируются от преждевременного выхода. Например, ``RootTask``, ``ChildTask`` и ``CallBackTask`` - это пользовательские функторы, которые наследуют ``tbb::task`` и реализуют его интерфейс. Далее, блокировка ``RootTask`` от преждевременного выхода и ожидание на ней реализуется следующим образом:"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:399
msgid ""
"#include <tbb/task.h>\n"
"\n"
"int main() {\n"
"    // Assuming RootTask, ChildTask, and CallBackTask are defined.\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{};\n"
"\n"
"    ChildTask&    child    = *new(root.allocate_child()) ChildTask{/*params*/};\n"
"    CallBackTask& cb_task  = *new(root.allocate_child()) CallBackTask{/*params*/};\n"
"\n"
"    root.set_ref_count(3);\n"
"\n"
"    tbb::task::spawn(child);\n"
"\n"
"    register_callback([cb_task&](){\n"
"        tbb::task::enqueue(cb_task);\n"
"    });\n"
"\n"
"    root.wait_for_all();\n"
"    // Control flow will reach here only after both ChildTask and CallBackTask are executed,\n"
"    // i.e. after the callback is called\n"
"}"
msgstr ""
"#include <tbb/task.h>\n"
"\n"
"int main() {\n"
"    // Assuming RootTask, ChildTask, and CallBackTask are defined.\n"
"    RootTask& root = *new(tbb::task::allocate_root()) RootTask{};\n"
"\n"
"    ChildTask&    child    = *new(root.allocate_child()) ChildTask{/*params*/};\n"
"    CallBackTask& cb_task  = *new(root.allocate_child()) CallBackTask{/*params*/};\n"
"\n"
"    root.set_ref_count(3);\n"
"\n"
"    tbb::task::spawn(child);\n"
"\n"
"    register_callback([cb_task&](){\n"
"        tbb::task::enqueue(cb_task);\n"
"    });\n"
"\n"
"    root.wait_for_all();\n"
"    // Control flow will reach here only after both ChildTask and CallBackTask are executed,\n"
"    // i.e. after the callback is called\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:425
msgid ""
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"int main(){\n"
"    oneapi::tbb::task_group tg;\n"
"    oneapi::tbb::task_arena arena;\n"
"    // Assuming ChildTask and CallBackTask are defined.\n"
"\n"
"    auto cb = tg.defer(CallBackTask{/*params*/});\n"
"\n"
"    register_callback([&tg, c = std::move(cb), &arena]{\n"
"        arena.enqueue(c);\n"
"    });\n"
"\n"
"    tg.run(ChildTask{/*params*/});\n"
"\n"
"\n"
"    tg.wait();\n"
"    // Control flow gets here once both ChildTask and CallBackTask are executed\n"
"    // i.e. after the callback is called\n"
"}"
msgstr ""
"#include <oneapi/tbb/task_group.h>\n"
"\n"
"int main(){\n"
"    oneapi::tbb::task_group tg;\n"
"    oneapi::tbb::task_arena arena;\n"
"    // Assuming ChildTask and CallBackTask are defined.\n"
"\n"
"    auto cb = tg.defer(CallBackTask{/*params*/});\n"
"\n"
"    register_callback([&tg, c = std::move(cb), &arena]{\n"
"        arena.enqueue(c);\n"
"    });\n"
"\n"
"    tg.run(ChildTask{/*params*/});\n"
"\n"
"\n"
"    tg.wait();\n"
"    // Control flow gets here once both ChildTask and CallBackTask are executed\n"
"    // i.e. after the callback is called\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:448
msgid "Here ``oneapi::tbb::task_group::defer`` adds a new task into the ``tg``. However, the task is not spawned until ``oneapi::tbb::task_arena::enqueue`` is called."
msgstr "Здесь ``oneapi::tbb::task_group::defer`` добавляет новую задачу в ``tg``. Однако задача не порождается до тех пор, пока не будет вызвана ``oneapi::tbb::task_arena::enqueue``."

#: ../../oneTBB/doc/main/tbb_userguide/Migration_Guide/Task_API.rst:452
msgid "The call to ``oneapi::tbb::task_group::wait`` will not return control until both ``ChildTask`` and ``CallBackTask`` are executed."
msgstr "Вызов ``oneapi::tbb::task_group::wait`` не вернет управление, пока не будут выполнены и ``ChildTask``, и ``CallBackTask``."
