# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-03-20 19:10+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:4
msgid "Using limiter_node"
msgstr "Использование limiter_node"

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:7
msgid "One way to limit resource consumption is to use a limiter_node to set a limit on the number of messages that can flow through a given point in your graph. The constructor for a limiter node takes two arguments:"
msgstr "Один из способов ограничить потребление ресурсов - использовать узел limiter_node, чтобы установить ограничение на количество сообщений, которые могут проходить через данную точку твоего графа. Конструктор узла ограничителя принимает два аргумента:"

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:15
msgid "limiter_node( graph &g, size_t threshold )"
msgstr "limiter_node( graph &g, size_t threshold )"

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:18
msgid "The first argument is a reference to the graph it belongs to. The second argument sets the maximum number of items that should be allowed to pass through before the node starts rejecting incoming messages."
msgstr "Первый аргумент - это ссылка на граф, к которому он принадлежит. Второй аргумент задает максимальное количество элементов, которые должны быть пропущены через узел, прежде чем он начнет отклонять входящие сообщения."

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:23
msgid "A limiter_node maintains an internal count of the messages that it has allowed to pass. When a message leaves the controlled part of the graph, a message can be sent to the decrement port on the ``limiter_node`` to decrement the count, allowing additional messages to pass through. In the example below, an ``input_node`` will generate ``M`` big objects. But the user wants to allow at most three big objects to reach the ``function_node`` at a time, and to prevent the ``input_node`` from generating all ``M`` big objects at once."
msgstr "Узел-ограничитель ведет внутренний подсчет сообщений, которые он пропустил. Когда сообщение покидает контролируемую часть графа, сообщение может быть отправлено в порт декремента на ``limiter_node``, чтобы уменьшить счетчик, позволяя пройти дополнительным сообщениям. В примере ниже ``input_node`` будет генерировать ``M`` больших объектов. Но пользователь хочет позволить не более чем трем большим объектам достичь ``function_node`` за один раз, и не дать ``input_node`` сгенерировать все ``M`` больших объектов сразу."

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:36
msgid ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"limiter_node< big_object * > l( g, max_objects );\n"
"\n"
"\n"
"function_node< big_object *, continue_msg > f( g, unlimited,\n"
"  []( big_object *v ) -> continue_msg {\n"
"    spin_for(1);\n"
"    delete v;\n"
"    return continue_msg();\n"
"} );\n"
"\n"
"\n"
"\n"
"\n"
"make_edge( l, f );\n"
"make_edge( f, l.decrement );\n"
"make_edge( s, l );\n"
"g.wait_for_all();"
msgstr ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"limiter_node< big_object * > l( g, max_objects );\n"
"\n"
"\n"
"function_node< big_object *, continue_msg > f( g, unlimited,\n"
"  []( big_object *v ) -> continue_msg {\n"
"    spin_for(1);\n"
"    delete v;\n"
"    return continue_msg();\n"
"} );\n"
"\n"
"\n"
"\n"
"\n"
"make_edge( l, f );\n"
"make_edge( f, l.decrement );\n"
"make_edge( s, l );\n"
"g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:75
msgid "The example above prevents the ``input_node`` from generating all ``M`` big objects at once. The ``limiter_node`` has a threshold of 3, and will therefore start rejecting incoming messages after its internal count reaches 3. When the ``input_node`` sees its message rejected, it stops calling its body object and temporarily buffers the last generated value. The ``function_node`` has its output, a ``continue_msg``, sent to the decrement port of the ``limiter_node``. So, after it completes executing, the ``limiter_node`` internal count is decremented. When the internal count drops below the threshold, messages begin flowing from the ``input_node`` again. So in this example, at most four big objects exist at a time, the three that have passed through the ``limiter_node`` and the one that is buffered in the ``input_node``."
msgstr "Приведенный пример не позволяет ``input_node`` сгенерировать все ``M`` больших объектов сразу. Узел ``limiter_node`` имеет порог в 3, и поэтому начнет отклонять входящие сообщения после того, как его внутренний счетчик достигнет 3. Когда узел ``input_node`` видит, что его сообщение отклонено, он прекращает вызов своего объекта body и временно буферизирует последнее сгенерированное значение. Узел ``function_node`` имеет свой выход, ``continue_msg``, отправленный в порт декремента узла ``limiter_node``. Таким образом, после завершения его выполнения внутренний счетчик узла ``limiter_node`` декрементируется. Когда внутренний счетчик опускается ниже порога, сообщения снова начинают поступать от ``input_node``. Таким образом, в этом примере одновременно существует не более четырех больших объектов: три, которые прошли через ``limiter_node``, и один, который буферизируется во ``input_node``."
