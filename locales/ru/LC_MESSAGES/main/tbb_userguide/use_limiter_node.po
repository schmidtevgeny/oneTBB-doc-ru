# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: oneTBB \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:4
msgid "Using limiter_node"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:7
msgid ""
"One way to limit resource consumption is to use a limiter_node to set a "
"limit on the number of messages that can flow through a given point in "
"your graph. The constructor for a limiter node takes two arguments:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:15
msgid "limiter_node( graph &g, size_t threshold )"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:18
msgid ""
"The first argument is a reference to the graph it belongs to. The second "
"argument sets the maximum number of items that should be allowed to pass "
"through before the node starts rejecting incoming messages."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:23
msgid ""
"A limiter_node maintains an internal count of the messages that it has "
"allowed to pass. When a message leaves the controlled part of the graph, "
"a message can be sent to the decrement port on the ``limiter_node`` to "
"decrement the count, allowing additional messages to pass through. In the"
" example below, an ``input_node`` will generate ``M`` big objects. But "
"the user wants to allow at most three big objects to reach the "
"``function_node`` at a time, and to prevent the ``input_node`` from "
"generating all ``M`` big objects at once."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:36
msgid ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> "
"big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"limiter_node< big_object * > l( g, max_objects );\n"
"\n"
"\n"
"function_node< big_object *, continue_msg > f( g, unlimited,\n"
"  []( big_object *v ) -> continue_msg {\n"
"    spin_for(1);\n"
"    delete v;\n"
"    return continue_msg();\n"
"} );\n"
"\n"
"\n"
"\n"
"\n"
"make_edge( l, f );\n"
"make_edge( f, l.decrement );\n"
"make_edge( s, l );\n"
"g.wait_for_all();"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/use_limiter_node.rst:75
msgid ""
"The example above prevents the ``input_node`` from generating all ``M`` "
"big objects at once. The ``limiter_node`` has a threshold of 3, and will "
"therefore start rejecting incoming messages after its internal count "
"reaches 3. When the ``input_node`` sees its message rejected, it stops "
"calling its body object and temporarily buffers the last generated value."
" The ``function_node`` has its output, a ``continue_msg``, sent to the "
"decrement port of the ``limiter_node``. So, after it completes executing,"
" the ``limiter_node`` internal count is decremented. When the internal "
"count drops below the threshold, messages begin flowing from the "
"``input_node`` again. So in this example, at most four big objects exist "
"at a time, the three that have passed through the ``limiter_node`` and "
"the one that is buffered in the ``input_node``."
msgstr ""

