# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-04-24 19:32+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/avoiding_data_races.rst:4
msgid "Avoiding Data Races"
msgstr "Избегание гонок данных"

#: ../../oneTBB/doc/main/tbb_userguide/avoiding_data_races.rst:7
msgid "The edges in a flow graph make explicit the dependence relationships that you want the library to enforce. Similarly, the concurrency limits on ``function_node`` and ``multifunction_node`` objects limit the maximum number of concurrent invocations that the runtime library will allow. These are the limits that are enforced by the library; the library does not automatically protect you from data races. You must explicitly prevent data races by using these mechanisms."
msgstr "Ребра в графе потока делают явными отношения зависимости, которые ты хочешь, чтобы библиотека соблюдала. Аналогично, ограничения параллелизма для объектов ``function_node`` и ``multifunction_node`` ограничивают максимальное количество одновременных вызовов, которые разрешит библиотека времени выполнения. Это ограничения, которые навязываются библиотекой; библиотека не защищает тебя автоматически от гонок данных. Ты должен явно предотвращать гонки данных, используя эти механизмы."

#: ../../oneTBB/doc/main/tbb_userguide/avoiding_data_races.rst:16
msgid "For example, the follow code has a data race because there is nothing to prevent concurrent accesses to the global count object referenced by node f:"
msgstr "Например, в следующем коде происходит гонка данных, потому что ничто не препятствует одновременному доступу к глобальному объекту count, на который ссылается узел f:"

#: ../../oneTBB/doc/main/tbb_userguide/avoiding_data_races.rst:24
msgid ""
"graph g;\n"
"int src_count = 1;\n"
"int global_sum = 0;\n"
"int limit = 100000;\n"
"\n"
"input_node< int > src( g, [&]( oneapi::tbb::flow_control& fc ) -> int {\n"
"  if ( src_count <= limit ) {\n"
"    return src_count++;\n"
"  } else {\n"
"    fc.stop();\n"
"    return int();\n"
"  }\n"
"} );\n"
"src.activate();\n"
"\n"
"function_node< int, int > f( g, unlimited, [&]( int i ) -> int {\n"
"  global_sum += i;  // data race on global_sum\n"
"  return i;\n"
"} );\n"
"\n"
"\n"
"make_edge( src, f );\n"
"g.wait_for_all();\n"
"\n"
"\n"
"cout << \"global sum = \" << global_sum\n"
"     << \" and closed form = \" << limit*(limit+1)/2 << \"\\n\";"
msgstr ""
"graph g;\n"
"int src_count = 1;\n"
"int global_sum = 0;\n"
"int limit = 100000;\n"
"\n"
"input_node< int > src( g, [&]( oneapi::tbb::flow_control& fc ) -> int {\n"
"  if ( src_count <= limit ) {\n"
"    return src_count++;\n"
"  } else {\n"
"    fc.stop();\n"
"    return int();\n"
"  }\n"
"} );\n"
"src.activate();\n"
"\n"
"function_node< int, int > f( g, unlimited, [&]( int i ) -> int {\n"
"  global_sum += i;  // data race on global_sum\n"
"  return i;\n"
"} );\n"
"\n"
"\n"
"make_edge( src, f );\n"
"g.wait_for_all();\n"
"\n"
"\n"
"cout << \"global sum = \" << global_sum\n"
"     << \" and closed form = \" << limit*(limit+1)/2 << \"\\n\";"

#: ../../oneTBB/doc/main/tbb_userguide/avoiding_data_races.rst:53
msgid "If you run the above example, it will likely calculate a global sum that is a bit smaller than the expected solution due to the data race. The data race could be avoided in this simple example by changing the allowed concurrency in ``f`` from unlimited to 1, forcing each value to be processed sequentially by ``f``. You may also note that the ``input_node`` also updates a global value, ``src_count``. However, since an ``input_node`` always executes serially, there is no race possible."
msgstr "Если ты выполнишь приведенный выше пример, он, скорее всего, вычислит глобальную сумму, которая будет немного меньше ожидаемого решения из-за гонки данных. В этом простом примере гонки данных можно избежать, изменив допустимый параллелизм в ``f`` с неограниченного на 1, заставляя каждое значение последовательно обрабатываться ``f``. Ты также можешь заметить, что узел ``input_node`` также обновляет глобальное значение ``rc_count``. Однако, поскольку ``input_node`` всегда выполняется последовательно, гонка невозможна."
