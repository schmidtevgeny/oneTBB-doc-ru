# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 14:17+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:4
msgid "Create a Token-Based System"
msgstr "Создание системы на основе токенов"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:7
msgid "A more flexible solution to limit the number of messages in a flow graph is to use tokens. In a token-based system, a limited number of tokens are available in the graph and a message will not be allowed to enter the graph until it can be paired with an available token. When a message is retired from the graph, its token is released, and can be paired with a new message that will then be allowed to enter."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:15
msgid "The ``oneapi::tbb::parallel_pipeline`` algorithm relies on a token-based system. In the flow graph interface, there is no explicit support for tokens, but ``join_node``s can be used to create an analogous system. A ``join_node`` has two template arguments, the tuple that describes the types of its inputs and a buffer policy:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:25
msgid ""
"template<typename OutputTuple, graph_buffer_policy JP = queueing>\n"
"class join_node;"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:29
msgid "The buffer policy can be one of the following:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:32
msgid "``queueing``. This type of policy causes inputs to be matched first-in-first-out; that is, the inputs are joined together to form a tuple in the order they are received."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:35
msgid "``tag_matching``. This type of policy joins inputs together that have matching tags."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:37
msgid "``reserving``. This type of policy causes the ``join_node`` to do no internally buffering, but instead to consume inputs only when it can first reserve an input on each port from an upstream source. If it can reserve an input at each port, it gets those inputs and joins those together to form an output tuple."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:44
msgid "A token-based system can be created by using reserving join_nodes."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:47
msgid "In the example below, there is an ``input_node`` that generates ``M`` big objects and a ``buffer_node`` that is pre-filled with three tokens. The ``token_t`` can be anything, for example it could be ``typedef int token_t;``. The ``input_node`` and ``buffer_node`` are connected to a reserving ``join_node``. The ``input_node`` will only generate an input when one is pulled from it by the reserving ``join_node``, and the reserving ``join_node`` will only pull the input from the ``input_node`` when it knows there is also an item to pull from the ``buffer_node``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:60
msgid ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"join_node< tuple_t, reserving > j(g);\n"
"\n"
"\n"
"buffer_node< token_t > b(g);\n"
"\n"
"\n"
"function_node< tuple_t, token_t > f( g, unlimited,\n"
"  []( const tuple_t &t ) -> token_t {\n"
"      spin_for(1);\n"
"   cout << get<1>(t) << \"\\n\";\n"
"      delete get<0>(t);\n"
"   return get<1>(t);\n"
"} );\n"
"\n"
"\n"
"make_edge( s, input_port<0>(j) );\n"
"make_edge( b, input_port<1>(j) );\n"
"make_edge( j, f );\n"
"make_edge( f, b );\n"
"\n"
"\n"
"b.try_put( 1 );\n"
"b.try_put( 2 );\n"
"b.try_put( 3 );\n"
"\n"
"\n"
"g.wait_for_all();"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:109
msgid "In the above code, you can see that the ``function_node`` returns the token back to the ``buffer_node``. This cycle in the flow graph allows the token to be recycled and paired with another input from the ``input_node``. So like in the previous sections, there will be at most four big objects in the graph. There could be three big objects in the ``function_node`` and one buffered in the ``input_node``, awaiting a token to be paired with."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:117
msgid "Since there is no specific ``token_t`` defined for the flow graph, you can use any type for a token, including objects or pointers to arrays. Therefore, unlike in the example above, the ``token_t`` doesn't need to be a dummy type; it could for example be a buffer or other object that is essential to the computation. We could, for example, modify the example above to use the big objects themselves as the tokens, removing the need to repeatedly allocate and deallocate them, and essentially create a free list of big objects using a cycle back to the ``buffer_node``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:127
msgid "Also, in our example above, the ``buffer_node`` was prefilled by a fixed number of explicit calls to ``try_put``, but there are other options. For example, an ``input_node`` could be attached to the input of the ``buffer_node``, and it could generate the tokens. In addition, our ``function_node`` could be replaced by a ``multifunction_node`` that can optionally put 0 or more outputs to each of its output ports. Using a ``multifunction_node``, you can choose to recycle or not recycle a token, or even generate more tokens, thereby increasing or decreasing the allowed concurrency in the graph."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:138
msgid "A token based system is therefore very flexible. You are free to declare the token to be of any type and to inject or remove tokens from the system as it is executing, thereby having dynamic control of the allowed concurrency in the system. Since you can pair the token with an input at the source, this approach enables you to limit resource consumption across the entire graph."
msgstr ""
