# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-03-20 19:21+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:4
msgid "Create a Token-Based System"
msgstr "Создание системы на основе токенов"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:7
msgid "A more flexible solution to limit the number of messages in a flow graph is to use tokens. In a token-based system, a limited number of tokens are available in the graph and a message will not be allowed to enter the graph until it can be paired with an available token. When a message is retired from the graph, its token is released, and can be paired with a new message that will then be allowed to enter."
msgstr "Более гибким решением для ограничения количества сообщений в графе потока является использование токенов. В системе, основанной на маркерах, в графе доступно ограниченное количество маркеров, и сообщение не будет допущено в граф, пока оно не будет сопряжено с доступным маркером. Когда сообщение выбывает из графа, его токен освобождается и может быть сопряжен с новым сообщением, которое затем будет допущено к входу."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:15
msgid "The ``oneapi::tbb::parallel_pipeline`` algorithm relies on a token-based system. In the flow graph interface, there is no explicit support for tokens, but ``join_node``s can be used to create an analogous system. A ``join_node`` has two template arguments, the tuple that describes the types of its inputs and a buffer policy:"
msgstr "Алгоритм ``oneapi::tbb::parallel_pipeline`` опирается на систему, основанную на токенах. В интерфейсе графа потока нет явной поддержки токенов, но ``join_node`` можно использовать для создания аналогичной системы. Узел ``join_node`` имеет два аргумента шаблона - кортеж, описывающий типы его входов, и буферную политику:"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:25
msgid ""
"template<typename OutputTuple, graph_buffer_policy JP = queueing>\n"
"class join_node;"
msgstr ""
"template<typename OutputTuple, graph_buffer_policy JP = queueing>\n"
"class join_node;"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:29
msgid "The buffer policy can be one of the following:"
msgstr "Буферная политика может быть одной из следующих:"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:32
msgid "``queueing``. This type of policy causes inputs to be matched first-in-first-out; that is, the inputs are joined together to form a tuple in the order they are received."
msgstr "``queueing``. Этот тип политики приводит к тому, что входы сопоставляются в порядке поступления; то есть входы объединяются в кортеж в порядке их поступления."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:35
msgid "``tag_matching``. This type of policy joins inputs together that have matching tags."
msgstr "``tag_matching``. Этот тип политики соединяет вместе входы, у которых совпадают теги."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:37
msgid "``reserving``. This type of policy causes the ``join_node`` to do no internally buffering, but instead to consume inputs only when it can first reserve an input on each port from an upstream source. If it can reserve an input at each port, it gets those inputs and joins those together to form an output tuple."
msgstr "``reserving``. Этот тип политики заставляет узел ``join_node`` не делать никакой внутренней буферизации, а вместо этого потреблять входы только тогда, когда он может сначала зарезервировать вход на каждом порту от источника восходящего потока. Если он может зарезервировать вход на каждом порту, он получает эти входы и соединяет их вместе, чтобы сформировать выходной кортеж."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:44
msgid "A token-based system can be created by using reserving join_nodes."
msgstr "Систему на основе токенов можно создать с помощью резервирования join_nodes."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:47
msgid "In the example below, there is an ``input_node`` that generates ``M`` big objects and a ``buffer_node`` that is pre-filled with three tokens. The ``token_t`` can be anything, for example it could be ``typedef int token_t;``. The ``input_node`` and ``buffer_node`` are connected to a reserving ``join_node``. The ``input_node`` will only generate an input when one is pulled from it by the reserving ``join_node``, and the reserving ``join_node`` will only pull the input from the ``input_node`` when it knows there is also an item to pull from the ``buffer_node``."
msgstr "В примере ниже есть узел ``input_node``, который генерирует большие объекты ``M``, и узел ``buffer_node``, который предварительно заполнен тремя токенами. ``token_t`` может быть чем угодно, например, это может быть ``typedef int token_t;``. Узлы ``input_node`` и ``buffer_node`` соединены с резервирующим узлом ``join_node``. Узел ``input_node`` будет генерировать вход только тогда, когда он будет извлечен из него резервирующим узлом ``join_node``, а резервирующий узел ``join_node`` будет извлекать вход из узла ``input_node`` только тогда, когда он знает, что есть элемент для извлечения из узла ``buffer_node``."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:60
msgid ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"join_node< tuple_t, reserving > j(g);\n"
"\n"
"\n"
"buffer_node< token_t > b(g);\n"
"\n"
"\n"
"function_node< tuple_t, token_t > f( g, unlimited,\n"
"  []( const tuple_t &t ) -> token_t {\n"
"      spin_for(1);\n"
"   cout << get<1>(t) << \"\\n\";\n"
"      delete get<0>(t);\n"
"   return get<1>(t);\n"
"} );\n"
"\n"
"\n"
"make_edge( s, input_port<0>(j) );\n"
"make_edge( b, input_port<1>(j) );\n"
"make_edge( j, f );\n"
"make_edge( f, b );\n"
"\n"
"\n"
"b.try_put( 1 );\n"
"b.try_put( 2 );\n"
"b.try_put( 3 );\n"
"\n"
"\n"
"g.wait_for_all();"
msgstr ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"join_node< tuple_t, reserving > j(g);\n"
"\n"
"\n"
"buffer_node< token_t > b(g);\n"
"\n"
"\n"
"function_node< tuple_t, token_t > f( g, unlimited,\n"
"  []( const tuple_t &t ) -> token_t {\n"
"      spin_for(1);\n"
"   cout << get<1>(t) << \"\\n\";\n"
"      delete get<0>(t);\n"
"   return get<1>(t);\n"
"} );\n"
"\n"
"\n"
"make_edge( s, input_port<0>(j) );\n"
"make_edge( b, input_port<1>(j) );\n"
"make_edge( j, f );\n"
"make_edge( f, b );\n"
"\n"
"\n"
"b.try_put( 1 );\n"
"b.try_put( 2 );\n"
"b.try_put( 3 );\n"
"\n"
"\n"
"g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:109
msgid "In the above code, you can see that the ``function_node`` returns the token back to the ``buffer_node``. This cycle in the flow graph allows the token to be recycled and paired with another input from the ``input_node``. So like in the previous sections, there will be at most four big objects in the graph. There could be three big objects in the ``function_node`` and one buffered in the ``input_node``, awaiting a token to be paired with."
msgstr "В приведенном выше коде ты видишь, что узел ``function_node`` возвращает токен обратно в узел ``buffer_node``. Этот цикл в графе потока позволяет повторно использовать токен и сопрягать его с другим входом из ``input_node``. Итак, как и в предыдущих разделах, в графе будет максимум четыре больших объекта. В ``function_node`` может быть три больших объекта, и один буферизованный в ``input_node``, ожидающий токена для сопряжения."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:117
msgid "Since there is no specific ``token_t`` defined for the flow graph, you can use any type for a token, including objects or pointers to arrays. Therefore, unlike in the example above, the ``token_t`` doesn't need to be a dummy type; it could for example be a buffer or other object that is essential to the computation. We could, for example, modify the example above to use the big objects themselves as the tokens, removing the need to repeatedly allocate and deallocate them, and essentially create a free list of big objects using a cycle back to the ``buffer_node``."
msgstr "Поскольку для графа потока не определен конкретный ``token_t``, ты можешь использовать для маркера любой тип, включая объекты или указатели на массивы. Поэтому, в отличие от примера выше, ``token_t`` не обязательно должен быть фиктивным типом; это может быть, например, буфер или другой объект, который необходим для вычислений. Мы можем, например, модифицировать приведенный выше пример, чтобы использовать сами большие объекты в качестве маркеров, устраняя необходимость многократно выделять и деаллоцировать их, и, по сути, создать свободный список больших объектов, используя цикл возврата к ``buffer_node``."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:127
msgid "Also, in our example above, the ``buffer_node`` was prefilled by a fixed number of explicit calls to ``try_put``, but there are other options. For example, an ``input_node`` could be attached to the input of the ``buffer_node``, and it could generate the tokens. In addition, our ``function_node`` could be replaced by a ``multifunction_node`` that can optionally put 0 or more outputs to each of its output ports. Using a ``multifunction_node``, you can choose to recycle or not recycle a token, or even generate more tokens, thereby increasing or decreasing the allowed concurrency in the graph."
msgstr "Кроме того, в нашем примере выше ``buffer_node`` был заполнен фиксированным количеством явных вызовов ``try_put``, но есть и другие варианты. Например, узел ``input_node`` может быть присоединен к входу узла ``buffer_node``, и он может генерировать токены. Кроме того, наш ``function_node`` можно заменить на ``multifunction_node``, который может по выбору подключать 0 или более выходов к каждому из своих выходных портов. Используя ``multifunction_node``, ты можешь выбрать, перерабатывать или не перерабатывать токен, или даже генерировать больше токенов, тем самым увеличивая или уменьшая допустимый параллелизм в графе."

#: ../../oneTBB/doc/main/tbb_userguide/create_token_based_system.rst:138
msgid "A token based system is therefore very flexible. You are free to declare the token to be of any type and to inject or remove tokens from the system as it is executing, thereby having dynamic control of the allowed concurrency in the system. Since you can pair the token with an input at the source, this approach enables you to limit resource consumption across the entire graph."
msgstr "Поэтому система, основанная на токенах, является очень гибкой. Ты волен объявлять маркер любого типа и вводить или удалять маркеры из системы по мере её выполнения, тем самым динамически контролируя допустимый параллелизм в системе. Поскольку ты можешь сопрягать токен с входом в источнике, такой подход позволяет тебе ограничить потребление ресурсов по всему графу."
