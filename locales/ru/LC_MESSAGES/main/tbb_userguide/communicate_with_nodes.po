# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-04-24 19:30+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:4
msgid "Communication Between Graphs"
msgstr "Связь между графами"

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:7
msgid "All graph nodes require a reference to a graph object as one of the arguments to their constructor. It is only safe to construct edges between nodes that are part of the same graph. An edge expresses the topology of your graph to the runtime library. Connecting two nodes in different graphs can make it difficult to reason about whole graph operations, such as calls to graph::wait_for_all and exception handling. To optimize performance, the library may make calls to a node's predecessor or successor at times that are unexpected by the user."
msgstr "Все узлы графа требуют ссылки на объект графа в качестве одного из аргументов своего конструктора. Безопасно строить ребра только между узлами, которые являются частью одного и того же графа. Ребро выражает топологию твоего графа для библиотеки времени выполнения. Соединение двух узлов в разных графах может затруднить рассуждения о целых операциях графа, таких как вызовы graph::wait_for_all и обработка исключений. Для оптимизации производительности библиотека может выполнять вызовы предшественника или преемника узла в неожиданные для пользователя моменты времени."

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:17
msgid "If two graphs must communicate, do NOT create an edge between them, but instead use explicit calls to try_put. This will prevent the runtime library from making any assumptions about the relationship of the two nodes, and therefore make it easier to reason about events that cross the graph boundaries. However, it may still be difficult to reason about whole graph operations. For example, consider the graphs below:"
msgstr "Если два графа должны взаимодействовать, НЕ создавай ребро между ними, а вместо этого используй явные вызовы try_put. Это не позволит библиотеке времени выполнения делать какие-либо предположения об отношениях двух узлов и, следовательно, облегчит рассуждения о событиях, которые пересекают границы графа. Тем не менее, рассуждать о целых операциях графа может быть все еще сложно. Например, рассмотрим приведенные ниже графы:"

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:28
msgid ""
"graph g;\n"
"function_node< int, int > n1( g, 1, [](int i) -> int {\n"
"    cout << \"n1\\n\";\n"
"    spin_for(i);\n"
"    return i;\n"
"} );\n"
"function_node< int, int > n2( g, 1, [](int i) -> int {\n"
"    cout << \"n2\\n\";\n"
"    spin_for(i);\n"
"    return i;\n"
"} );\n"
"make_edge( n1, n2 );\n"
"\n"
"\n"
"graph g2;\n"
"function_node< int, int > m1( g2, 1, [](int i) -> int {\n"
"    cout << \"m1\\n\";\n"
"    spin_for(i);\n"
"    return i;\n"
"} );\n"
"function_node< int, int > m2( g2, 1, [&](int i) -> int {\n"
"    cout << \"m2\\n\";\n"
"    spin_for(i);\n"
"    n1.try_put(i);\n"
"    return i;\n"
"} );\n"
"make_edge( m1, m2 );\n"
"\n"
"\n"
"m1.try_put( 1 );\n"
"\n"
"\n"
"// The following call returns immediately:\n"
"g.wait_for_all();\n"
"// The following call returns after m1 & m2\n"
"g2.wait_for_all();\n"
"\n"
"\n"
"// we reach here before n1 & n2 are finished\n"
"// even though wait_for_all was called on both graphs"
msgstr ""
"graph g;\n"
"function_node< int, int > n1( g, 1, [](int i) -> int {\n"
"    cout << \"n1\\n\";\n"
"    spin_for(i);\n"
"    return i;\n"
"} );\n"
"function_node< int, int > n2( g, 1, [](int i) -> int {\n"
"    cout << \"n2\\n\";\n"
"    spin_for(i);\n"
"    return i;\n"
"} );\n"
"make_edge( n1, n2 );\n"
"\n"
"\n"
"graph g2;\n"
"function_node< int, int > m1( g2, 1, [](int i) -> int {\n"
"    cout << \"m1\\n\";\n"
"    spin_for(i);\n"
"    return i;\n"
"} );\n"
"function_node< int, int > m2( g2, 1, [&](int i) -> int {\n"
"    cout << \"m2\\n\";\n"
"    spin_for(i);\n"
"    n1.try_put(i);\n"
"    return i;\n"
"} );\n"
"make_edge( m1, m2 );\n"
"\n"
"\n"
"m1.try_put( 1 );\n"
"\n"
"\n"
"// The following call returns immediately:\n"
"g.wait_for_all();\n"
"// The following call returns after m1 & m2\n"
"g2.wait_for_all();\n"
"\n"
"\n"
"// we reach here before n1 & n2 are finished\n"
"// even though wait_for_all was called on both graphs"

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:70
msgid "In the example above, m1.try_put(1) sends a message to node m1, which runs its body and then sends a message to node m2. Next, node m2 runs its body and sends a message to n1 using an explicit try_put. In turn, n1 runs its body and sends a message to n2. The runtime library does not consider m2 to be a predecessor of n1 since no edge exists."
msgstr "В приведенном выше примере m1.try_put(1) отправляет сообщение узлу m1, который выполняет свое тело, а затем отправляет сообщение узлу m2. Далее узел m2 выполняет свое тело и отправляет сообщение узлу n1, используя явный try_put. В свою очередь, n1 запускает свое тело и отправляет сообщение n2. Библиотека времени выполнения не считает m2 предшественником n1, так как не существует грани."

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:77
msgid "If you want to wait until all of the tasks spawned by these graphs are done, you need to call the function wait_for_all on both graphs. However, because there is cross-graph communication, the order of the calls is important. In the (incorrect) code segment above, the first call to g.wait_for_all() returns immediately because there are no tasks yet active in g; the only tasks that have been spawned by then belong to g2. The call to g2.wait_for_all returns after both m1 and m2 are done, since they belong to g2; the call does not however wait for n1 and n2, since they belong to g. The end of this code segment is therefore reached before n1 and n2 are done."
msgstr "Если ты хочешь подождать, пока все задачи, порожденные этими графами, будут выполнены, тебе нужно вызвать функцию wait_for_all на обоих графах. Однако, поскольку существует кросс-графовая коммуникация, порядок вызовов важен. В приведенном выше (неправильном) сегменте кода первый вызов g.wait_for_all() возвращается немедленно, потому что в g еще нет активных задач; единственные задачи, которые были порождены к этому моменту, принадлежат g2. Вызов g2.wait_for_all возвращается после того, как m1 и m2 будут выполнены, поскольку они принадлежат g2; однако этот вызов не дожидается n1 и n2, поскольку они принадлежат g. Поэтому конец этого сегмента кода достигается до того, как n1 и n2 будут выполнены."

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:89
msgid "If the calls to wait_for_all are swapped, the code works as expected:"
msgstr "Если поменять местами вызовы wait_for_all, то код работает, как и ожидалось:"

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:95
msgid ""
"g2.wait_for_all();\n"
"g.wait_for_all();\n"
"\n"
"\n"
"// all tasks are done"
msgstr ""
"g2.wait_for_all();\n"
"g.wait_for_all();\n"
"\n"
"\n"
"// all tasks are done"

#: ../../oneTBB/doc/main/tbb_userguide/communicate_with_nodes.rst:102
msgid "While it is not too difficult to reason about how these two very small graphs interact, the interaction of two larger graphs, perhaps with cycles, will be more difficult to understand. Therefore, communication between nodes in different graphs should be done with caution."
msgstr "Хотя рассуждать о том, как взаимодействуют эти два очень маленьких графа, не слишком сложно, взаимодействие двух более крупных графов, возможно, с циклами, будет понять сложнее. Поэтому общение между узлами в разных графах должно осуществляться с осторожностью."
