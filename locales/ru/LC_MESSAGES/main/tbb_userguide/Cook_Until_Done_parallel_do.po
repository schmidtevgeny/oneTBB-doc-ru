# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: oneTBB \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:4
msgid "Cook Until Done: parallel_for_each"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:7
msgid ""
"For some loops, the end of the iteration space is not known in advance, "
"or the loop body may add more iterations to do before the loop exits. You"
" can deal with both situations using the template class "
"``oneapi::tbb::parallel_for_each``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:12
msgid ""
"A linked list is an example of an iteration space that is not known in "
"advance. In parallel programming, it is usually better to use dynamic "
"arrays instead of linked lists, because accessing items in a linked list "
"is inherently serial. But if you are limited to linked lists, the items "
"can be safely processed in parallel, and processing each item takes at "
"least a few thousand instructions, you can use ``parallel_for_each`` to "
"gain some parallelism."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:21
msgid "For example, consider the following serial code:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:27
msgid ""
"void SerialApplyFooToList( const std::list<Item>& list ) {\n"
"    for( std::list<Item>::const_iterator i=list.begin() i!=list.end(); "
"++i )\n"
"        Foo(*i);\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:33
msgid ""
"If ``Foo`` takes at least a few thousand instructions to run, you can get"
" parallel speedup by converting the loop to use ``parallel_for_each``. To"
" do so, define an object with a ``const`` qualified ``operator()``. This "
"is similar to a C++ function object from the C++ standard header "
"``<functional>``, except that ``operator()`` must be ``const``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:44
msgid ""
"class ApplyFoo {\n"
"public:\n"
"    void operator()( Item& item ) const {\n"
"        Foo(item);\n"
"    }\n"
"};"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:52
msgid "The parallel form of ``SerialApplyFooToList`` is as follows:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:58
msgid ""
"void ParallelApplyFooToList( const std::list<Item>& list ) {\n"
"    parallel_for_each( list.begin(), list.end(), ApplyFoo() );\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:63
msgid ""
"An invocation of ``parallel_for_each`` never causes two threads to act on"
" an input iterator concurrently. Thus typical definitions of input "
"iterators for sequential programs work correctly. This convenience makes "
"``parallel_for_each`` unscalable, because the fetching of work is serial."
" But in many situations, you still get useful speedup over doing things "
"sequentially."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:71
msgid "There are two ways that ``parallel_for_each`` can acquire work scalably."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:74
msgid "The iterators can be random-access iterators."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Cook_Until_Done_parallel_do.rst:77
msgid ""
"The body argument to ``parallel_for_each``, if it takes a second argument"
" *feeder* of type ``parallel_for_each<Item>&``, can add more work by "
"calling ``feeder.add(item)``. For example, suppose processing a node in a"
" tree is a prerequisite to processing its descendants. With "
"``parallel_for_each``, after processing a node, you could use "
"``feeder.add`` to add the descendant nodes. The instance of "
"``parallel_for_each`` does not terminate until all items have been "
"processed."
msgstr ""

