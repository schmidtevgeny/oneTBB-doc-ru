# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: oneTBB \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:4
msgid "Working on the Assembly Line: parallel_pipeline"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:7
msgid ""
"*Pipelining* is a common parallel pattern that mimics a traditional "
"manufacturing assembly line. Data flows through a series of pipeline "
"filters and each filter processes the data in some way. Given an incoming"
" stream of data, some of these filters can operate in parallel, and "
"others cannot. For example, in video processing, some operations on "
"frames do not depend on other frames, and so can be done on multiple "
"frames at the same time. On the other hand, some operations on frames "
"require processing prior frames first."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:17
msgid ""
"The |full_name| classes ``parallel_pipeline`` and filter implement the "
"pipeline pattern. A simple text processing example will be used to "
"demonstrate the usage of ``parallel_pipeline`` and filter to perform "
"parallel formatting. The example reads a text file, squares each decimal "
"numeral in the text, and writes the modified text to a new file. Below is"
" a picture of the pipeline."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:27
msgid ""
"Since the body object provided to the filters of the ``parallel_pipline``"
" might be copied, its ``operator()`` should not modify the body. "
"Otherwise the modification might or might not become visible to the "
"thread that invoked ``parallel_pipeline``, depending upon whether "
"``operator()`` is acting on the original or a copy. As a reminder of this"
" nuance, ``parallel_pipeline`` requires that the body object's "
"``operator()`` be declared ``const``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:42
msgid "Read chunk from input file"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:43
msgid "|image0|"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:344
msgid "image0"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:344
#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:347
msgid ".. image:: main/tbb_userguide/Images/image010.jpg"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:44
msgid "Square numerals in chunk"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:45
msgid "|image1|"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:347
msgid "image1"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:46
msgid "Write chunk to output file"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:51
msgid ""
"Assume that the raw file I/O is sequential. The squaring filter can be "
"done in parallel. That is, if you can serially read ``n`` chunks very "
"quickly, you can transform each of the ``n`` chunks in parallel, as long "
"as they are written in the proper order to the output file. Though the "
"raw I/O is sequential, the formatting of input and output can be moved to"
" the middle filter, and thus be parallel."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:59
msgid ""
"To amortize parallel scheduling overheads, the filters operate on chunks "
"of text. Each input chunk is approximately 4000 characters. Each chunk is"
" represented by an instance of class ``TextSlice``:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:67
msgid ""
"// Holds a slice of text.\n"
"/** Instances *must* be allocated/freed using methods herein, because the"
" C++ declaration\n"
"   represents only the header of a much larger object in memory. */\n"
"class TextSlice {\n"
"    // Pointer to one past last character in sequence\n"
"    char* logical_end;\n"
"    // Pointer to one past last available byte in sequence.\n"
"    char* physical_end;\n"
"public:\n"
"    // Allocate a TextSlice object that can hold up to max_size "
"characters.\n"
"    static TextSlice* allocate( size_t max_size ) {\n"
"        // +1 leaves room for a terminating null character.\n"
"        TextSlice* t = "
"(TextSlice*)oneapi::tbb::tbb_allocator<char>().allocate( "
"sizeof(TextSlice)+max_size+1 );\n"
"        t->logical_end = t->begin();\n"
"        t->physical_end = t->begin()+max_size;\n"
"        return t;\n"
"    }\n"
"    // Free this TextSlice object\n"
"    void free() {\n"
"        oneapi::tbb::tbb_allocator<char>().deallocate((char*)this, "
"sizeof(TextSlice)+(physical_end-begin())+1);\n"
"    }\n"
"    // Pointer to beginning of sequence\n"
"    char* begin() {return (char*)(this+1);}\n"
"    // Pointer to one past last character in sequence\n"
"    char* end() {return logical_end;}\n"
"    // Length of sequence\n"
"    size_t size() const {return logical_end-(char*)(this+1);}\n"
"    // Maximum number of characters that can be appended to sequence\n"
"    size_t avail() const {return physical_end-logical_end;}\n"
"    // Append sequence [first,last) to this sequence.\n"
"    void append( char* first, char* last ) {\n"
"        memcpy( logical_end, first, last-first );\n"
"        logical_end += last-first;\n"
"    }\n"
"    // Set end() to given value.\n"
"    void set_end( char* p ) {logical_end=p;}\n"
"};"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:106
msgid ""
"Below is the top-level code for building and running the pipeline. "
"``TextSlice`` objects are passed between filters using pointers to avoid "
"the overhead of copying a ``TextSlice``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:114
msgid ""
"void RunPipeline( int ntoken, FILE* input_file, FILE* output_file ) {\n"
"    oneapi::tbb::parallel_pipeline(\n"
"        ntoken,\n"
"        oneapi::tbb::make_filter<void,TextSlice*>(\n"
"            oneapi::tbb::filter::serial_in_order, MyInputFunc(input_file)"
" )\n"
"    &\n"
"        oneapi::tbb::make_filter<TextSlice*,TextSlice*>(\n"
"            oneapi::tbb::filter::parallel, MyTransformFunc() )\n"
"    &\n"
"        oneapi::tbb::make_filter<TextSlice*,void>(\n"
"            oneapi::tbb::filter::serial_in_order, "
"MyOutputFunc(output_file) ) );\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:128
msgid ""
"The parameter ``ntoken`` to method ``parallel_pipeline`` controls the "
"level of parallelism. Conceptually, tokens flow through the pipeline. In "
"a serial in-order filter, each token must be processed serially in order."
" In a parallel filter, multiple tokens can by processed in parallel by "
"the filter. If the number of tokens were unlimited, there might be a "
"problem where the unordered filter in the middle keeps gaining tokens "
"because the output filter cannot keep up. This situation typically leads "
"to undesirable resource consumption by the middle filter. The parameter "
"to method ``parallel_pipeline`` specifies the maximum number of tokens "
"that can be in flight. Once this limit is reached, the pipeline never "
"creates a new token at the input filter until another token is destroyed "
"at the output filter."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:142
msgid ""
"The second parameter specifies the sequence of filters. Each filter is "
"constructed by function ``make_filter<inputType, "
"outputType>(mode,functor)``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:146
msgid ""
"The *inputType* specifies the type of values input by a filter. For the "
"input filter, the type is ``void``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:150
msgid ""
"The *outputType* specifies the type of values output by a filter. For the"
" output filter, the type is ``void``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:154
msgid ""
"The *mode* specifies whether the filter processes items in parallel, "
"serial in-order, or serial out-of-order."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:158
msgid ""
"The *functor* specifies how to produce an output value from an input "
"value."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:162
msgid ""
"The filters are concatenated with ``operator&``. When concatenating two "
"filters, the *outputType* of the first filter must match the *inputType* "
"of the second filter."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:167
msgid ""
"The filters can be constructed and concatenated ahead of time. An "
"equivalent version of the previous example that does this follows:"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:174
msgid ""
"void RunPipeline( int ntoken, FILE* input_file, FILE* output_file ) {\n"
"    oneapi::tbb::filter<void,TextSlice*> f1( "
"oneapi::tbb::filter::serial_in_order,\n"
"                                       MyInputFunc(input_file) );\n"
"    oneapi::tbb::filter<TextSlice*,TextSlice*> "
"f2(oneapi::tbb::filter::parallel,\n"
"                                            MyTransformFunc() );\n"
"    oneapi::tbb::filter<TextSlice*,void> "
"f3(oneapi::tbb::filter::serial_in_order,\n"
"                                      MyOutputFunc(output_file) );\n"
"    oneapi::tbb::filter<void,void> f = f1 & f2 & f3;\n"
"    oneapi::tbb::parallel_pipeline(ntoken,f);\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:186
msgid ""
"The input filter must be ``serial_in_order`` in this example because the "
"filter reads chunks from a sequential file and the output filter must "
"write the chunks in the same order. All ``serial_in_order`` filters "
"process items in the same order. Thus if an item arrives at "
"``MyOutputFunc`` out of the order established by ``MyInputFunc``, the "
"pipeline automatically delays invoking ``MyOutputFunc::operator()`` on "
"the item until its predecessors are processed. There is another kind of "
"serial filter, ``serial_out_of_order``, that does not preserve order."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:196
msgid ""
"The middle filter operates on purely local data. Thus any number of "
"invocations of its functor can run concurrently. Hence it is specified as"
" a parallel filter."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:201
msgid ""
"The functors for each filter are explained in detail now. The output "
"functor is the simplest. All it has to do is write a ``TextSlice`` to a "
"file and free the ``TextSlice``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:209
#, python-format
msgid ""
"// Functor that writes a TextSlice to a file.\n"
"class MyOutputFunc {\n"
"    FILE* my_output_file;\n"
"public:\n"
"    MyOutputFunc( FILE* output_file );\n"
"    void operator()( TextSlice* item ) const;\n"
"};\n"
"\n"
"\n"
"MyOutputFunc::MyOutputFunc( FILE* output_file ) :\n"
"    my_output_file(output_file)\n"
"{\n"
"}\n"
"\n"
"\n"
"void MyOutputFunc::operator()( TextSlice* out ) const {\n"
"    size_t n = fwrite( out->begin(), 1, out->size(), my_output_file );\n"
"    if( n!=out->size() ) {\n"
"        fprintf(stderr,\"Can't write into file '%s'\\n\", "
"OutputFileName);\n"
"        exit(1);\n"
"    }\n"
"    out->free();\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:234
msgid ""
"Method ``operator()`` processes a ``TextSlice``. The parameter ``out`` "
"points to the ``TextSlice`` to be processed. Since it is used for the "
"last filter of the pipeline, it returns ``void``."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:239
msgid ""
"The functor for the middle filter is similar, but a bit more complex. It "
"returns a pointer to the ``TextSlice`` that it produces."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:246
#, python-format
msgid ""
"// Functor that changes each decimal number to its square.\n"
"class MyTransformFunc {\n"
"public:\n"
"    TextSlice* operator()( TextSlice* input ) const;\n"
"};\n"
"\n"
"\n"
"TextSlice* MyTransformFunc::operator()( TextSlice* input ) const {\n"
"    // Add terminating null so that strtol works right even if number is "
"at end of the input.\n"
"    *input->end() = '\\0';\n"
"    char* p = input->begin();\n"
"    TextSlice* out = TextSlice::allocate( 2*MAX_CHAR_PER_INPUT_SLICE );\n"
"    char* q = out->begin();\n"
"    for(;;) {\n"
"        while( p<input->end() && !isdigit(*p) )\n"
"            *q++ = *p++;\n"
"        if( p==input->end() )\n"
"            break;\n"
"        long x = strtol( p, &p, 10 );\n"
"        // Note: no overflow checking is needed here, as we have twice "
"the\n"
"        // input string length, but the square of a non-negative integer "
"n\n"
"        // cannot have more than twice as many digits as n.\n"
"        long y = x*x;\n"
"        sprintf(q,\"%ld\",y);\n"
"        q = strchr(q,0);\n"
"    }\n"
"    out->set_end(q);\n"
"    input->free();\n"
"    return out;\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:278
msgid ""
"The input functor is the most complicated, because it has to ensure that "
"no numeral crosses a boundary. When it finds what could be a numeral "
"crossing into the next slice, it copies the partial numeral to the next "
"slice. Furthermore, it has to indicate when the end of input is reached. "
"It does this by invoking method ``stop()`` on a special argument of type "
"``flow_control``. This idiom is required for any functor used for the "
"first filter of a pipline."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:289
msgid ""
"TextSlice* next_slice = NULL;\n"
"\n"
"\n"
"class MyInputFunc {\n"
"public:\n"
"    MyInputFunc( FILE* input_file_ );\n"
"    MyInputFunc( const MyInputFunc& f ) : input_file(f.input_file) { }\n"
"    ~MyInputFunc();\n"
"    TextSlice* operator()( oneapi::tbb::flow_control& fc ) const;\n"
"private:\n"
"    FILE* input_file;\n"
"};\n"
"\n"
"\n"
"MyInputFunc::MyInputFunc( FILE* input_file_ ) :\n"
"    input_file(input_file_) { }\n"
"\n"
"\n"
"MyInputFunc::~MyInputFunc() {\n"
"}\n"
"\n"
"\n"
"TextSlice* MyInputFunc::operator()( oneapi::tbb::flow_control& fc ) const"
" {\n"
"    // Read characters into space that is available in the next slice.\n"
"    if( !next_slice )\n"
"        next_slice = TextSlice::allocate( MAX_CHAR_PER_INPUT_SLICE );\n"
"    size_t m = next_slice->avail();\n"
"    size_t n = fread( next_slice->end(), 1, m, input_file );\n"
"    if( !n && next_slice->size()==0 ) {\n"
"        // No more characters to process\n"
"        fc.stop();\n"
"        return NULL;\n"
"    } else {\n"
"        // Have more characters to process.\n"
"        TextSlice* t = next_slice;\n"
"        next_slice = TextSlice::allocate( MAX_CHAR_PER_INPUT_SLICE );\n"
"        char* p = t->end()+n;\n"
"        if( n==m ) {\n"
"            // Might have read partial number.\n"
"            // If so, transfer characters of partial number to next "
"slice.\n"
"            while( p>t->begin() && isdigit(p[-1]) )\n"
"                --p;\n"
"            assert(p>t->begin(),\"Number too large to fit in "
"buffer.\\n\");\n"
"            next_slice->append( p, t->end()+n );\n"
"        }\n"
"        t->set_end(p);\n"
"        return t;\n"
"    }\n"
"}"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Working_on_the_Assembly_Line_pipeline.rst:340
msgid ""
"The copy constructor must be defined because the functor is copied when "
"the underlying ``oneapi::tbb::filter_t`` is built from the functor, and "
"again when the pipeline runs."
msgstr ""

