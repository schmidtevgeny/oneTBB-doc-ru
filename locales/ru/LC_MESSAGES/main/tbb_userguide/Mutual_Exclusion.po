# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-04-24 20:24+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:4
msgid "Mutual Exclusion"
msgstr "Взаимное исключение"

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:7
msgid "Mutual exclusion controls how many threads can simultaneously run a region of code. In |full_name|, mutual exclusion is implemented by *mutexes* and *locks.* A mutex is an object on which a thread can acquire a lock. Only one thread at a time can have a lock on a mutex; other threads have to wait their turn."
msgstr "Взаимное исключение контролирует, сколько потоков могут одновременно выполнять ту или иную область кода. В |full_name| взаимное исключение реализуется с помощью *мьютексов* и *блокировок.* Мьютекс - это объект, на который поток может получить блокировку. Только один поток одновременно может иметь блокировку на мьютексе; другие потоки должны ждать своей очереди."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:14
msgid "The simplest mutex is ``spin_mutex``. A thread trying to acquire a lock on a ``spin_mutex`` busy waits until it can acquire the lock. A ``spin_mutex`` is appropriate when the lock is held for only a few instructions. For example, the following code uses a mutex ``FreeListMutex`` to protect a shared variable ``FreeList``. It checks that only a single thread has access to ``FreeList`` at a time."
msgstr "Самый простой мьютекс - это ``spin_mutex``. Поток, пытающийся получить блокировку на занятом ``spin_mutex``, ждет, пока он сможет получить блокировку. ``spin_mutex`` подходит, когда блокировка удерживается всего на несколько инструкций. Например, следующий код использует мьютекс ``FreeListMutex`` для защиты общей переменной ``FreeList``. Он проверяет, что только один поток имеет доступ к ``FreeList`` одновременно."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:23
msgid ""
"Node* FreeList;\n"
"typedef spin_mutex FreeListMutexType;\n"
"FreeListMutexType FreeListMutex;\n"
"\n"
"\n"
"Node* AllocateNode() {\n"
"    Node* n;\n"
"    {\n"
"        FreeListMutexType::scoped_lock lock(FreeListMutex);\n"
"        n = FreeList;\n"
"        if( n )\n"
"            FreeList = n->next;\n"
"    }\n"
"    if( !n )\n"
"        n = new Node();\n"
"    return n;\n"
"}\n"
"\n"
"\n"
"void FreeNode( Node* n ) {\n"
"    FreeListMutexType::scoped_lock lock(FreeListMutex);\n"
"    n->next = FreeList;\n"
"    FreeList = n;\n"
"}"
msgstr ""
"Node* FreeList;\n"
"typedef spin_mutex FreeListMutexType;\n"
"FreeListMutexType FreeListMutex;\n"
"\n"
"\n"
"Node* AllocateNode() {\n"
"    Node* n;\n"
"    {\n"
"        FreeListMutexType::scoped_lock lock(FreeListMutex);\n"
"        n = FreeList;\n"
"        if( n )\n"
"            FreeList = n->next;\n"
"    }\n"
"    if( !n )\n"
"        n = new Node();\n"
"    return n;\n"
"}\n"
"\n"
"\n"
"void FreeNode( Node* n ) {\n"
"    FreeListMutexType::scoped_lock lock(FreeListMutex);\n"
"    n->next = FreeList;\n"
"    FreeList = n;\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:49
msgid "The constructor for ``scoped_lock`` waits until there are no other locks on ``FreeListMutex``. The destructor releases the lock. The braces inside routine ``AllocateNode`` may look unusual. Their role is to keep the lifetime of the lock as short as possible, so that other waiting threads can get their chance as soon as possible."
msgstr "Конструктор для ``scoped_lock`` ждет, пока не будет других блокировок на ``FreeListMutex``. Деструктор освобождает блокировку. Скобки внутри рутины ``AllocateNode`` могут выглядеть необычно. Их роль заключается в том, чтобы сделать время жизни блокировки как можно короче, чтобы другие ожидающие потоки могли получить свой шанс как можно скорее."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:57
msgid "Be sure to name the lock object, otherwise it will be destroyed too soon. For example, if the creation of the ``scoped_lock`` object in the example is changed to"
msgstr "Обязательно присвой объекту блокировки имя, иначе он будет уничтожен слишком рано. Например, если создание объекта ``scoped_lock`` в примере изменить на"

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:63
msgid "FreeListMutexType::scoped_lock (FreeListMutex);"
msgstr "FreeListMutexType::scoped_lock (FreeListMutex);"

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:65
msgid "then the ``scoped_lock`` is destroyed when execution reaches the semicolon, which releases the lock *before* ``FreeList`` is accessed."
msgstr "то ``scoped_lock`` уничтожается, когда выполнение достигает точки с запятой, что освобождает блокировку *перед* обращением к ``FreeList``."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:69
msgid "The following shows an alternative way to write ``AllocateNode``:"
msgstr "Ниже показан альтернативный способ написания ``AllocateNode``:"

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:75
msgid ""
"Node* AllocateNode() {\n"
"    Node* n;\n"
"    FreeListMutexType::scoped_lock lock;\n"
"    lock.acquire(FreeListMutex);\n"
"    n = FreeList;\n"
"    if( n )\n"
"        FreeList = n->next;\n"
"    lock.release();\n"
"    if( !n )\n"
"        n = new Node();\n"
"    return n;\n"
"}"
msgstr ""
"Node* AllocateNode() {\n"
"    Node* n;\n"
"    FreeListMutexType::scoped_lock lock;\n"
"    lock.acquire(FreeListMutex);\n"
"    n = FreeList;\n"
"    if( n )\n"
"        FreeList = n->next;\n"
"    lock.release();\n"
"    if( !n )\n"
"        n = new Node();\n"
"    return n;\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:89
msgid "Method ``acquire`` waits until it can acquire a lock on the mutex; method ``release`` releases the lock."
msgstr "Метод ``acquire`` ждет, пока не сможет приобрести блокировку на мьютексе; метод ``release`` освобождает блокировку."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:93
msgid "It is recommended that you add extra braces where possible, to clarify to maintainers which code is protected by the lock."
msgstr "Рекомендуется, по возможности, добавлять дополнительные скобки, чтобы пояснить сопровождающим, какой код защищен блокировкой."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:97
msgid "If you are familiar with C interfaces for locks, you may be wondering why there are not simply acquire and release methods on the mutex object itself. The reason is that the C interface would not be exception safe, because if the protected region threw an exception, control would skip over the release. With the object-oriented interface, destruction of the ``scoped_lock`` object causes the lock to be released, no matter whether the protected region was exited by normal control flow or an exception. This is true even for our version of ``AllocateNode`` that used methods ``acquire`` and ``release –`` the explicit release causes the lock to be released earlier, and the destructor then sees that the lock was released and does nothing."
msgstr "Если ты знаком с интерфейсами C для блокировок, то тебе может быть интересно, почему на самом объекте мьютекса нет просто методов ``acquire`` и ``release``. Причина в том, что интерфейс языка Си не был бы безопасным для исключений, потому что если бы защищенная область выбросила исключение, управление пропустило бы освобождение. В объектно-ориентированном интерфейсе уничтожение объекта ``scoped_lock`` приводит к освобождению блокировки, независимо от того, была ли защищённая область выведена обычным потоком управления или исключением. Это верно даже для нашей версии ``AllocateNode``, которая использовала методы ``acquire`` и ``release - явное освобождение приводит к тому, что блокировка освобождается раньше, а деструктор видит, что блокировка была освобождена, и ничего не делает."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:110
msgid "All mutexes in oneTBB have a similar interface, which not only makes them easier to learn, but enables generic programming. For example, all of the mutexes have a nested ``scoped_lock`` type, so given a mutex of type ``M``, the corresponding lock type is ``M::scoped_lock``."
msgstr "Все мьютексы в oneTBB имеют схожий интерфейс, что не только облегчает их изучение, но и позволяет осуществлять универсальное программирование. Например, все мьютексы имеют вложенный тип ``scoped_lock``, поэтому, если дать мьютексу тип ``M``, то соответствующий тип блокировки будет ``M::scoped_lock``."

#: ../../oneTBB/doc/main/tbb_userguide/Mutual_Exclusion.rst:117
msgid "It is recommended that you always use a ``typedef`` for the mutex type, as shown in the previous examples. That way, you can change the type of the lock later without having to edit the rest of the code. In the examples, you could replace the ``typedef`` with ``typedef queuing_mutex FreeListMutexType``, and the code would still be correct."
msgstr "Рекомендуется, чтобы ты всегда использовал ``typedef`` для типа мьютекса, как показано в предыдущих примерах. Таким образом, ты сможешь изменить тип блокировки позже без необходимости редактировать остальной код. В примерах ты можешь заменить ``typedef`` на ``typedef queuing_mutex FreeListMutexType``, и код все равно будет правильным."
