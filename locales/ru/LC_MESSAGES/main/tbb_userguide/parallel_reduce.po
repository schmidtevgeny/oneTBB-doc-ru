# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 23:08+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:4
msgid "parallel_reduce"
msgstr "parallel_reduce"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:7
msgid "A loop can do a reduction, as in this summation:"
msgstr "Цикл может выполнять свертку, как в этом суммировании:"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:13
msgid ""
"float SerialSumFoo( float a[], size_t n ) {\n"
"    float sum = 0;\n"
"    for( size_t i=0; i!=n; ++i )\n"
"        sum += Foo(a[i]);\n"
"    return sum;\n"
"}"
msgstr ""
"float SerialSumFoo( float a[], size_t n ) {\n"
"    float sum = 0;\n"
"    for( size_t i=0; i!=n; ++i )\n"
"        sum += Foo(a[i]);\n"
"    return sum;\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:21
msgid "If the iterations are independent, you can parallelize this loop using the template class ``parallel_reduce`` as follows:"
msgstr "Если итерации независимы, ты можешь распараллелить этот цикл с помощью шаблонного класса ``parallel_reduce`` следующим образом:"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:28
msgid ""
"float ParallelSumFoo( const float a[], size_t n ) {\n"
"    SumFoo sf(a);\n"
"    parallel_reduce( blocked_range<size_t>(0,n), sf );\n"
"    return sf.my_sum;\n"
"}"
msgstr ""
"float ParallelSumFoo( const float a[], size_t n ) {\n"
"    SumFoo sf(a);\n"
"    parallel_reduce( blocked_range<size_t>(0,n), sf );\n"
"    return sf.my_sum;\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:35
msgid "The class ``SumFoo`` specifies details of the reduction, such as how to accumulate subsums and combine them. Here is the definition of class ``SumFoo``:"
msgstr "Класс ``SumFoo`` определяет детали свертки, например, как накапливать подсуммы и объединять их. Вот определение класса ``SumFoo``:"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:43
msgid ""
"class SumFoo {\n"
"    float* my_a;\n"
"public:\n"
"    float my_sum;\n"
"    void operator()( const blocked_range<size_t>& r ) {\n"
"        float *a = my_a;\n"
"        float sum = my_sum;\n"
"        size_t end = r.end();\n"
"        for( size_t i=r.begin(); i!=end; ++i )\n"
"            sum += Foo(a[i]);\n"
"        my_sum = sum;\n"
"    }\n"
"\n"
"\n"
"    SumFoo( SumFoo& x, split ) : my_a(x.my_a), my_sum(0) {}\n"
"\n"
"\n"
"    void join( const SumFoo& y ) {my_sum+=y.my_sum;}\n"
"\n"
"\n"
"    SumFoo(float a[] ) :\n"
"        my_a(a), my_sum(0)\n"
"    {}\n"
"};"
msgstr ""
"class SumFoo {\n"
"    float* my_a;\n"
"public:\n"
"    float my_sum;\n"
"    void operator()( const blocked_range<size_t>& r ) {\n"
"        float *a = my_a;\n"
"        float sum = my_sum;\n"
"        size_t end = r.end();\n"
"        for( size_t i=r.begin(); i!=end; ++i )\n"
"            sum += Foo(a[i]);\n"
"        my_sum = sum;\n"
"    }\n"
"\n"
"\n"
"    SumFoo( SumFoo& x, split ) : my_a(x.my_a), my_sum(0) {}\n"
"\n"
"\n"
"    void join( const SumFoo& y ) {my_sum+=y.my_sum;}\n"
"\n"
"\n"
"    SumFoo(float a[] ) :\n"
"        my_a(a), my_sum(0)\n"
"    {}\n"
"};"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:69
msgid "Note the differences with class ``ApplyFoo`` from parallel_for. First, ``operator()`` is *not* ``const``. This is because it must update SumFoo::my_sum. Second, ``SumFoo`` has a *splitting constructor* and a method ``join`` that must be present for ``parallel_reduce`` to work. The splitting constructor takes as arguments a reference to the original object, and a dummy argument of type ``split``, which is defined by the library. The dummy argument distinguishes the splitting constructor from a copy constructor."
msgstr "Обрати внимание на различия с классом ``ApplyFoo`` из parallel_for. Во-первых, ``operator()`` является *не* ``const``. Это потому, что он должен обновлять SumFoo::my_sum. Во-вторых, у ``SumFoo`` есть конструктор *разделения* и метод ``join``, которые должны присутствовать для работы ``parallel_reduce``. Конструктор разделения принимает в качестве аргументов ссылку на исходный объект и фиктивный аргумент типа ``split`, который определяется библиотекой. Фиктивный аргумент отличает конструктор расщепления от конструктора копирования."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:80
msgid "In the example, the definition of ``operator()`` uses local temporary variables (``a``, ``sum``, ``end``) for scalar values accessed inside the loop. This technique can improve performance by making it obvious to the compiler that the values can be held in registers instead of memory. If the values are too large to fit in registers, or have their address taken in a way the compiler cannot track, the technique might not help. With a typical optimizing compiler, using local temporaries for only written variables (such as ``sum`` in the example) can suffice, because then the compiler can deduce that the loop does not write to any of the other locations, and hoist the other reads to outside the loop."
msgstr "В примере определение ``operator()`` использует локальные временные переменные (``a``, ``sum``, ``end``) для скалярных значений, доступных внутри цикла. Эта техника может улучшить производительность, делая очевидным для компилятора, что значения могут храниться в регистрах, а не в памяти. Если значения слишком велики, чтобы поместиться в регистры, или их адрес взят таким образом, что компилятор не может его отследить, эта техника может не помочь. Для типичного оптимизирующего компилятора может быть достаточно использования локальных временных хранилищ только для записанных переменных (таких как ``sum`` в примере), потому что тогда компилятор может сделать вывод, что цикл не записывает ни в одно из других мест, и перенести остальные чтения за пределы цикла."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:93
msgid "When a worker thread is available, as decided by the task scheduler, ``parallel_reduce`` invokes the splitting constructor to create a subtask for the worker. When the subtask completes, ``parallel_reduce`` uses method ``join`` to accumulate the result of the subtask. The graph at the top of the following figure shows the split-join sequence that happens when a worker is available:"
msgstr "Когда рабочий поток доступен, что определяется планировщиком задач, ``parallel_reduce`` вызывает конструктор расщепления, чтобы создать подзадачу для рабочего потока. Когда подзадача завершается, ``parallel_reduce`` использует метод ``join`` для накопления результата подзадачи. График в верхней части следующего рисунка показывает последовательность split-join, которая происходит, когда доступен рабочий поток:"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:105
msgid "Graph of the Split-join Sequence |image0|"
msgstr "Граф последовательности Split-join |image0|"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:183
msgid "image0"
msgstr "image0"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:183
msgid ".. image:: main/tbb_userguide/Images/image009.jpg"
msgstr ".. image:: main/tbb_userguide/Images/image009.jpg"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:109
msgid "An arrows in the above figure indicate order in time. The splitting constructor might run concurrently while object ``x`` is being used for the first half of the reduction. Therefore, all actions of the splitting constructor that creates y must be made thread safe with respect to ``x``. So if the splitting constructor needs to increment a reference count shared with other objects, it should use an atomic increment."
msgstr "Стрелки на рисунке выше указывают на порядок во времени. Конструктор расщепления может выполняться параллельно, пока объект ``x`` используется для первой половины интревала. Поэтому все действия конструктора расщепления, создающего y, должны быть потокобезопасными по отношению к ``x``. Поэтому если конструктору расщепления нужно увеличить счетчик ссылок, разделяемый с другими объектами, он должен использовать атомарный инкремент."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:117
msgid "If a worker is not available, the second half of the iteration is reduced using the same body object that reduced the first half. That is the reduction of the second half starts where reduction of the first half finished."
msgstr "Если рабочего потока нет, то вторая половина итерации сокращается с использованием того же объекта тела, который сокращал первую половину. То есть редукция второй половины начинается там, где закончилась редукция первой половины."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:124
msgid "Since split/join are not used if workers are unavailable, ``parallel_reduce`` does not necessarily do recursive splitting."
msgstr "Поскольку split/join не используются, если свободные потоки недоступны, ``parallel_reduce`` не обязательно выполняет рекурсивное расщепление."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:129
msgid "Since the same body might be used to accumulate multiple subranges, it is critical that ``operator()`` not discard earlier accumulations. The code below shows an incorrect definition of ``SumFoo::operator()``."
msgstr "Поскольку одно и то же тело может использоваться для накопления нескольких подрезультатов, очень важно, чтобы ``operator()`` не отбрасывал более ранние накопления. Код ниже показывает неправильное определение ``SumFoo::operator()``."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:138
msgid ""
"class SumFoo {\n"
"    ...\n"
"public:\n"
"    float my_sum;\n"
"    void operator()( const blocked_range<size_t>& r ) {\n"
"        ...\n"
"        float sum = 0;  // WRONG – should be 'sum = my_sum\".\n"
"        ...\n"
"        for( ... )\n"
"            sum += Foo(a[i]);\n"
"        my_sum = sum;\n"
"    }\n"
"    ...\n"
"};"
msgstr ""
"class SumFoo {\n"
"    ...\n"
"public:\n"
"    float my_sum;\n"
"    void operator()( const blocked_range<size_t>& r ) {\n"
"        ...\n"
"        float sum = 0;  // WRONG – should be 'sum = my_sum\".\n"
"        ...\n"
"        for( ... )\n"
"            sum += Foo(a[i]);\n"
"        my_sum = sum;\n"
"    }\n"
"    ...\n"
"};"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:154
msgid "With the mistake, the body returns a partial sum for the last subrange instead of all subranges to which ``parallel_reduce`` applies it."
msgstr "При ошибке тело возвращает частичную сумму для последнего поддиапазона вместо всех поддиапазонов, к которым применяется ``parallel_reduce``."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:158
msgid "The rules for partitioners and grain sizes for ``parallel_reduce`` are the same as for ``parallel_for``."
msgstr "Правила для разделителей и размеров зерен для ``parallel_reduce`` такие же, как и для ``parallel_for``."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:162
msgid "``parallel_reduce`` generalizes to any associative operation. In general, the splitting constructor does two things:"
msgstr "``parallel_reduce`` обобщается на любую ассоциативную операцию. В общем, конструктор расщепления делает две вещи:"

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:166
msgid "Copy read-only information necessary to run the loop body."
msgstr "Скопируй информацию только для чтения, необходимую для запуска тела цикла."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:169
msgid "Initialize the reduction variable(s) to the identity element of the operation(s)."
msgstr "Инициализируй переменную(ые) редукции на элемент(ы) идентичности операции(ий)."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:173
msgid "The join method should do the corresponding merge(s). You can do more than one reduction at the same time: you can gather the min and max with a single ``parallel_reduce``."
msgstr "Метод join должен выполнить соответствующее слияние (слияния). Ты можешь выполнять более одной свертки одновременно: ты можешь собрать min и max с помощью одного ``parallel_reduce``."

#: ../../oneTBB/doc/main/tbb_userguide/parallel_reduce.rst:179
msgid "The reduction operation can be non-commutative. The example still works if floating-point addition is replaced by string concatenation."
msgstr "Операция редукции может быть некоммутативной. Пример по-прежнему работает, если сложение с плавающей точкой заменить конкатенацией строк."
