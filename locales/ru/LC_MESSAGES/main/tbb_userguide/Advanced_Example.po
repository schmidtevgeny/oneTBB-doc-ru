# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-23 15:30+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:4
msgid "Advanced Example"
msgstr "Расширенный пример"

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:7
msgid "An example of a more advanced associative operation is to find the index where ``Foo(i)`` is minimized. A serial version might look like this:"
msgstr "Примером более сложной ассоциативной операции является нахождение индекса, при котором ``Foo(i)`` минимизируется. Последовательная версия может выглядеть следующим образом:"

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:14
msgid ""
"long SerialMinIndexFoo( const float a[], size_t n ) {\n"
"    float value_of_min = FLT_MAX;        // FLT_MAX from <climits>\n"
"    long index_of_min = -1;\n"
"    for( size_t i=0; i<n; ++i ) {\n"
"        float value = Foo(a[i]);\n"
"        if( value<value_of_min ) {\n"
"            value_of_min = value;\n"
"            index_of_min = i;\n"
"        }\n"
"    }\n"
"    return index_of_min;\n"
"}"
msgstr ""
"long SerialMinIndexFoo( const float a[], size_t n ) {\n"
"    float value_of_min = FLT_MAX;        // FLT_MAX from <climits>\n"
"    long index_of_min = -1;\n"
"    for( size_t i=0; i<n; ++i ) {\n"
"        float value = Foo(a[i]);\n"
"        if( value<value_of_min ) {\n"
"            value_of_min = value;\n"
"            index_of_min = i;\n"
"        }\n"
"    }\n"
"    return index_of_min;\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:28
msgid "The loop works by keeping track of the minimum value found so far, and the index of this value. This is the only information carried between loop iterations. To convert the loop to use ``parallel_reduce``, the function object must keep track of the carried information, and how to merge this information when iterations are spread across multiple threads. Also, the function object must record a pointer to ``a`` to provide context."
msgstr "Цикл работает, отслеживая минимальное значение, найденное на данный момент, и индекс этого значения. Это единственная информация, переносимая между итерациями цикла. Чтобы преобразовать цикл для использования ``parallel_reduce``, объект функции должен отслеживать переносимую информацию, и как объединить эту информацию, когда итерации распределены по нескольким потокам. Кроме того, объект функции должен записать указатель на ``a`` для обеспечения контекста."

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:37
msgid "The following code shows the complete function object."
msgstr "Следующий код показывает полный объект функции."

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:43
msgid ""
"class MinIndexFoo {\n"
"    const float *const my_a;\n"
"public:\n"
"    float value_of_min;\n"
"    long index_of_min;\n"
"    void operator()( const blocked_range<size_t>& r ) {\n"
"        const float *a = my_a;\n"
"        for( size_t i=r.begin(); i!=r.end(); ++i ) {\n"
"           float value = Foo(a[i]);\n"
"           if( value<value_of_min ) {\n"
"               value_of_min = value;\n"
"               index_of_min = i;\n"
"           }\n"
"        }\n"
"    }\n"
"\n"
"\n"
"    MinIndexFoo( MinIndexFoo& x, split ) :\n"
"        my_a(x.my_a),\n"
"        value_of_min(FLT_MAX),    // FLT_MAX from <climits>\n"
"        index_of_min(-1)\n"
"   {}\n"
"\n"
"\n"
"    void join( const SumFoo& y ) {\n"
"        if( y.value_of_min<value_of_min ) {\n"
"            value_of_min = y.value_of_min;\n"
"            index_of_min = y.index_of_min;\n"
"        }\n"
"    }\n"
"\n"
"\n"
"    MinIndexFoo( const float a[] ) :\n"
"        my_a(a),\n"
"        value_of_min(FLT_MAX),    // FLT_MAX from <climits>\n"
"        index_of_min(-1),\n"
"    {}\n"
"};"
msgstr ""
"class MinIndexFoo {\n"
"    const float *const my_a;\n"
"public:\n"
"    float value_of_min;\n"
"    long index_of_min;\n"
"    void operator()( const blocked_range<size_t>& r ) {\n"
"        const float *a = my_a;\n"
"        for( size_t i=r.begin(); i!=r.end(); ++i ) {\n"
"           float value = Foo(a[i]);\n"
"           if( value<value_of_min ) {\n"
"               value_of_min = value;\n"
"               index_of_min = i;\n"
"           }\n"
"        }\n"
"    }\n"
"\n"
"\n"
"    MinIndexFoo( MinIndexFoo& x, split ) :\n"
"        my_a(x.my_a),\n"
"        value_of_min(FLT_MAX),    // FLT_MAX from <climits>\n"
"        index_of_min(-1)\n"
"   {}\n"
"\n"
"\n"
"    void join( const SumFoo& y ) {\n"
"        if( y.value_of_min<value_of_min ) {\n"
"            value_of_min = y.value_of_min;\n"
"            index_of_min = y.index_of_min;\n"
"        }\n"
"    }\n"
"\n"
"\n"
"    MinIndexFoo( const float a[] ) :\n"
"        my_a(a),\n"
"        value_of_min(FLT_MAX),    // FLT_MAX from <climits>\n"
"        index_of_min(-1),\n"
"    {}\n"
"};"

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:83
msgid "Now ``SerialMinIndex`` can be rewritten using ``parallel_reduce`` as shown below:"
msgstr "Теперь ``SerialMinIndex`` можно переписать с помощью ``parallel_reduce``, как показано ниже:"

#: ../../oneTBB/doc/main/tbb_userguide/Advanced_Example.rst:90
msgid ""
"long ParallelMinIndexFoo( float a[], size_t n ) {\n"
"    MinIndexFoo mif(a);\n"
"    parallel_reduce(blocked_range<size_t>(0,n), mif );\n"
"\n"
"\n"
" return mif.index_of_min;\n"
"}"
msgstr ""
"long ParallelMinIndexFoo( float a[], size_t n ) {\n"
"    MinIndexFoo mif(a);\n"
"    parallel_reduce(blocked_range<size_t>(0,n), mif );\n"
"\n"
"\n"
" return mif.index_of_min;\n"
"}"
