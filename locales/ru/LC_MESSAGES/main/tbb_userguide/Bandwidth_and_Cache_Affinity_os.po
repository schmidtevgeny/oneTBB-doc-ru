# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 22:53+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:4
msgid "Bandwidth and Cache Affinity"
msgstr "Пропускная способность и сродство кэша"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:7
msgid "For a sufficiently simple function ``Foo``, the examples might not show good speedup when written as parallel loops. The cause could be insufficient system bandwidth between the processors and memory. In that case, you may have to rethink your algorithm to take better advantage of cache. Restructuring to better utilize the cache usually benefits the parallel program as well as the serial program."
msgstr "Для достаточно простой функции ``Foo`` примеры могут не показать хорошего ускорения при написании в виде параллельных циклов. Причиной может быть недостаточная пропускная способность системы между процессорами и памятью. В этом случае тебе, возможно, придется переосмыслить свой алгоритм, чтобы лучше использовать преимущества кэша. Реструктуризация для лучшего использования кэша обычно приносит пользу как параллельной программе, так и последовательной."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:15
msgid "An alternative to restructuring that works in some cases is ``affinity_partitioner.`` It not only automatically chooses the grainsize, but also optimizes for cache affinity and tries to distribute the data uniformly among threads. Using ``affinity_partitioner`` can significantly improve performance when:"
msgstr "Альтернативой реструктуризации, которая работает в некоторых случаях, является ``affinity_partitioner.`` Он не только автоматически выбирает размер зерна, но также оптимизирует сродство кэша и пытается равномерно распределить данные между потоками. Использование ``affinity_partitioner`` может значительно улучшить производительность, когда:"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:22
msgid "The computation does a few operations per data access."
msgstr "Вычисления выполняют несколько операций за один доступ к данным."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:25
msgid "The data acted upon by the loop fits in cache."
msgstr "Данные, с которыми работает цикл, помещаются в кэш."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:28
msgid "The loop, or a similar loop, is re-executed over the same data."
msgstr "Этот цикл или похожий цикл повторно выполняется над теми же данными."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:31
msgid "There are more than two hardware threads available (and especially if the number of threads is not a power of two). If only two threads are available, the default scheduling in |full_name| usually provides sufficient cache affinity."
msgstr "Доступно более двух аппаратных потоков (и особенно если число потоков не является степенью двойки). Если доступны только два потока, то планирование по умолчанию в |full_name| обычно обеспечивает достаточное сродство кэша."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:37
msgid "The following code shows how to use ``affinity_partitioner``."
msgstr "Следующий код показывает, как использовать ``affinity_partitioner``."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:43
msgid ""
"#include \"oneapi/tbb.h\"\n"
"\n"
"\n"
"void ParallelApplyFoo( float a[], size_t n ) {\n"
"    static affinity_partitioner ap;\n"
"    parallel_for(blocked_range<size_t>(0,n), ApplyFoo(a), ap);\n"
"}\n"
"\n"
"\n"
"void TimeStepFoo( float a[], size_t n, int steps ) {\n"
"    for( int t=0; t<steps; ++t )\n"
"        ParallelApplyFoo( a, n );\n"
"}"
msgstr ""
"#include \"oneapi/tbb.h\"\n"
"\n"
"\n"
"void ParallelApplyFoo( float a[], size_t n ) {\n"
"    static affinity_partitioner ap;\n"
"    parallel_for(blocked_range<size_t>(0,n), ApplyFoo(a), ap);\n"
"}\n"
"\n"
"\n"
"void TimeStepFoo( float a[], size_t n, int steps ) {\n"
"    for( int t=0; t<steps; ++t )\n"
"        ParallelApplyFoo( a, n );\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:58
msgid "In the example, the ``affinity_partitioner`` object ``ap`` lives between loop iterations. It remembers where iterations of the loop ran, so that each iteration can be handed to the same thread that executed it before. The example code gets the lifetime of the partitioner right by declaring the ``affinity_partitioner`` as a local static object. Another approach would be to declare it at a scope outside the iterative loop in ``TimeStepFoo``, and hand it down the call chain to ``parallel_for``."
msgstr "В примере объект ``affinity_partitioner`` ``ap`` живет между итерациями цикла. Он запоминает, где проходили итерации цикла, так что каждая итерация может быть передана тому же потоку, который выполнял её раньше. Код примера правильно определяет время жизни разделителя, объявляя ``affinity_partitioner`` как локальный статический объект. Другим подходом было бы объявить его в области видимости вне итерационного цикла в ``TimeStepFoo``, и передать его по цепочке вызовов в ``parallel_for``."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:67
msgid "If the data does not fit across the system’s caches, there may be little benefit. The following figure shows the situations."
msgstr "Если данные не помещаются во всех кэшах системы, пользы может быть мало. На следующем рисунке показаны такие ситуации."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:75
msgid "Benefit of Affinity Determined by Relative Size of Data Set and Cache |image0|"
msgstr "Преимущество сродства определяется относительным размером набора данных и кэша |image0|"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:101
msgid "image0"
msgstr "image0"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:101
msgid ".. image:: main/tbb_userguide/Images/image007.jpg"
msgstr ".. image:: main/tbb_userguide/Images/image007.jpg"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:79
msgid "The next figure shows how parallel speedup might vary with the size of a data set. The computation for the example is ``A[i]+=B[i]`` for ``i`` in the range [0,N). It was chosen for dramatic effect. You are unlikely to see quite this much variation in your code. The graph shows not much improvement at the extremes. For small N, parallel scheduling overhead dominates, resulting in little speedup. For large N, the data set is too large to be carried in cache between loop invocations. The peak in the middle is the sweet spot for affinity. Hence ``affinity_partitioner`` should be considered a tool, not a cure-all, when there is a low ratio of computations to memory accesses."
msgstr "Следующий рисунок показывает, как параллельное ускорение может меняться в зависимости от размера набора данных. Вычисления для примера - ``A[i]+=B[i]`` для ``i`` в диапазоне [0,N). Это было выбрано для драматического эффекта. Вряд ли ты встретишь в своем коде столько вариаций. На графике видно, что в крайних значениях улучшение незначительно. При малых N доминируют накладные расходы на параллельное планирование, что приводит к незначительному ускорению. Для большого N набор данных слишком велик, чтобы переносить его в кэш между вызовами цикла. Пик посередине - это \"сладкая точка\" для сродства. Следовательно, ``affinity_partitioner`` следует рассматривать как инструмент, а не панацею, когда соотношение вычислений и обращений к памяти невелико."

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:95
msgid "Improvement from Affinity Dependent on Array Size |image1|"
msgstr "Улучшение сродства в зависимости от размера массива |image1|"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:104
msgid "image1"
msgstr "image1"

#: ../../oneTBB/doc/main/tbb_userguide/Bandwidth_and_Cache_Affinity_os.rst:104
msgid ".. image:: main/tbb_userguide/Images/image008.jpg"
msgstr ".. image:: main/tbb_userguide/Images/image008.jpg"
