# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-03-20 19:08+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_flow_graphs.rst:4
msgid "Use Nested Flow Graphs"
msgstr "Использование вложенных графов потоков"

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_flow_graphs.rst:7
msgid "In addition to nesting algorithms within a flow graph node, it is also possible to nest flow graphs. For example, below there is a graph ``g`` with two nodes, ``a`` and ``b``. When node ``a`` receives a message, it constructs and executes an inner dependence graph. When node ``b`` receives a message, it constructs and executes an inner data flow graph:"
msgstr "Помимо вложения алгоритмов в узлы графа потока, можно также вложить графы потока. Например, ниже представлен граф ``g`` с двумя узлами, ``a`` и ``b``. Когда узел ``a`` получает сообщение, он строит и выполняет внутренний граф зависимостей. Когда узел ``b`` получает сообщение, он строит и выполняет внутренний граф потока данных:"

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_flow_graphs.rst:17
msgid ""
"graph g;\n"
"  function_node< int, int > a( g, unlimited, []( int i ) -> int {\n"
"      graph h;\n"
"      node_t n1( h, [=]( msg_t ) { cout << \"n1: \" << i << \"\\n\"; } );\n"
"      node_t n2( h, [=]( msg_t ) { cout << \"n2: \" << i << \"\\n\"; } );\n"
"      node_t n3( h, [=]( msg_t ) { cout << \"n3: \" << i << \"\\n\"; } );\n"
"      node_t n4( h, [=]( msg_t ) { cout << \"n4: \" << i << \"\\n\"; } );\n"
"      make_edge( n1, n2 );\n"
"      make_edge( n1, n3 );\n"
"      make_edge( n2, n4 );\n"
"      make_edge( n3, n4 );\n"
"      n1.try_put(continue_msg());\n"
"      h.wait_for_all();\n"
"      return i;\n"
"  } );\n"
"  function_node< int, int > b( g, unlimited, []( int i ) -> int {\n"
"      graph h;\n"
"      function_node< int, int > m1( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m1: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      function_node< int, int > m2( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m2: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      function_node< int, int > m3( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m3: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      function_node< int, int > m4( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m4: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      make_edge( m1, m2 );\n"
"      make_edge( m1, m3 );\n"
"      make_edge( m2, m4 );\n"
"      make_edge( m3, m4 );\n"
"      m1.try_put(i);\n"
"      h.wait_for_all();\n"
"      return i;\n"
"  } );\n"
"  make_edge( a, b );\n"
"  for ( int i = 0; i < 3; ++i ) {\n"
"      a.try_put(i);\n"
"  }\n"
"  g.wait_for_all();"
msgstr ""
"graph g;\n"
"  function_node< int, int > a( g, unlimited, []( int i ) -> int {\n"
"      graph h;\n"
"      node_t n1( h, [=]( msg_t ) { cout << \"n1: \" << i << \"\\n\"; } );\n"
"      node_t n2( h, [=]( msg_t ) { cout << \"n2: \" << i << \"\\n\"; } );\n"
"      node_t n3( h, [=]( msg_t ) { cout << \"n3: \" << i << \"\\n\"; } );\n"
"      node_t n4( h, [=]( msg_t ) { cout << \"n4: \" << i << \"\\n\"; } );\n"
"      make_edge( n1, n2 );\n"
"      make_edge( n1, n3 );\n"
"      make_edge( n2, n4 );\n"
"      make_edge( n3, n4 );\n"
"      n1.try_put(continue_msg());\n"
"      h.wait_for_all();\n"
"      return i;\n"
"  } );\n"
"  function_node< int, int > b( g, unlimited, []( int i ) -> int {\n"
"      graph h;\n"
"      function_node< int, int > m1( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m1: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      function_node< int, int > m2( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m2: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      function_node< int, int > m3( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m3: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      function_node< int, int > m4( h, unlimited, []( int j ) -> int {\n"
"          cout << \"m4: \" << j << \"\\n\";\n"
"          return j;\n"
"      } );\n"
"      make_edge( m1, m2 );\n"
"      make_edge( m1, m3 );\n"
"      make_edge( m2, m4 );\n"
"      make_edge( m3, m4 );\n"
"      m1.try_put(i);\n"
"      h.wait_for_all();\n"
"      return i;\n"
"  } );\n"
"  make_edge( a, b );\n"
"  for ( int i = 0; i < 3; ++i ) {\n"
"      a.try_put(i);\n"
"  }\n"
"  g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_flow_graphs.rst:65
msgid "If the nested graph remains unchanged in structure between invocations of the node, it is redundant to construct it each time. Reconstructing the graph only adds overhead to the execution. You can modify the example above, for example, to have node ``b`` reuse a graph that is persistent across its invocations:"
msgstr "Если вложенный граф остается неизменным по структуре между вызовами узла, то строить его каждый раз излишне. Реконструкция графа только добавляет накладные расходы на выполнение. Ты можешь изменить приведенный выше пример, например, чтобы узел ``b`` повторно использовал граф, который является постоянным во всех его вызовах:"

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_flow_graphs.rst:75
msgid ""
"graph h;\n"
"  function_node< int, int > m1( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m1: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  function_node< int, int > m2( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m2: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  function_node< int, int > m3( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m3: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  function_node< int, int > m4( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m4: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  make_edge( m1, m2 );\n"
"  make_edge( m1, m3 );\n"
"  make_edge( m2, m4 );\n"
"  make_edge( m3, m4 );\n"
"\n"
"\n"
"  graph g;\n"
"  function_node< int, int > a( g, unlimited, []( int i ) -> int {\n"
"      graph h;\n"
"      node_t n1( h, [=]( msg_t ) { cout << \"n1: \" << i << \"\\n\"; } );\n"
"      node_t n2( h, [=]( msg_t ) { cout << \"n2: \" << i << \"\\n\"; } );\n"
"      node_t n3( h, [=]( msg_t ) { cout << \"n3: \" << i << \"\\n\"; } );\n"
"      node_t n4( h, [=]( msg_t ) { cout << \"n4: \" << i << \"\\n\"; } );\n"
"      make_edge( n1, n2 );\n"
"      make_edge( n1, n3 );\n"
"      make_edge( n2, n4 );\n"
"      make_edge( n3, n4 );\n"
"      n1.try_put(continue_msg());\n"
"      h.wait_for_all();\n"
"      return i;\n"
"  } );\n"
"  function_node< int, int > b( g, unlimited, [&]( int i ) -> int {\n"
"      m1.try_put(i);\n"
"      h.wait_for_all(); // optional since h is not destroyed\n"
"      return i;\n"
"  } );\n"
"  make_edge( a, b );\n"
"  for ( int i = 0; i < 3; ++i ) {\n"
"      a.try_put(i);\n"
"  }\n"
"  g.wait_for_all();"
msgstr ""
"graph h;\n"
"  function_node< int, int > m1( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m1: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  function_node< int, int > m2( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m2: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  function_node< int, int > m3( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m3: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  function_node< int, int > m4( h, unlimited, []( int j ) -> int {\n"
"      cout << \"m4: \" << j << \"\\n\";\n"
"      return j;\n"
"  } );\n"
"  make_edge( m1, m2 );\n"
"  make_edge( m1, m3 );\n"
"  make_edge( m2, m4 );\n"
"  make_edge( m3, m4 );\n"
"\n"
"\n"
"  graph g;\n"
"  function_node< int, int > a( g, unlimited, []( int i ) -> int {\n"
"      graph h;\n"
"      node_t n1( h, [=]( msg_t ) { cout << \"n1: \" << i << \"\\n\"; } );\n"
"      node_t n2( h, [=]( msg_t ) { cout << \"n2: \" << i << \"\\n\"; } );\n"
"      node_t n3( h, [=]( msg_t ) { cout << \"n3: \" << i << \"\\n\"; } );\n"
"      node_t n4( h, [=]( msg_t ) { cout << \"n4: \" << i << \"\\n\"; } );\n"
"      make_edge( n1, n2 );\n"
"      make_edge( n1, n3 );\n"
"      make_edge( n2, n4 );\n"
"      make_edge( n3, n4 );\n"
"      n1.try_put(continue_msg());\n"
"      h.wait_for_all();\n"
"      return i;\n"
"  } );\n"
"  function_node< int, int > b( g, unlimited, [&]( int i ) -> int {\n"
"      m1.try_put(i);\n"
"      h.wait_for_all(); // optional since h is not destroyed\n"
"      return i;\n"
"  } );\n"
"  make_edge( a, b );\n"
"  for ( int i = 0; i < 3; ++i ) {\n"
"      a.try_put(i);\n"
"  }\n"
"  g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/use_nested_flow_graphs.rst:125
msgid "It is only necessary to call ``h.wait_for_all()`` at the end of each invocation of ``b``'s body in our modified code, if you wish for this ``b``'s body to block until the inner graph is done. In the first implementation of ``b``, it was necessary to call ``h.wait_for_all`` at the end of each invocation since the graph was destroyed at the end of the scope. So it would be valid in the body of ``b`` above to call ``m1.try_put(i)`` and then return without waiting for ``h`` to become idle."
msgstr "Вызывать ``h.wait_for_all()`` в конце каждого вызова тела ``b`` в нашем модифицированном коде необходимо только в том случае, если ты хочешь, чтобы тело этого ``b`` блокировалось до тех пор, пока внутренний граф не будет завершен. В первой реализации ``b`` было необходимо вызывать ``h.wait_for_all`` в конце каждого вызова, поскольку граф уничтожался в конце области видимости. Поэтому в теле ``b`` выше было бы правильно вызвать ``m1.try_put(i)`` и затем вернуться, не дожидаясь, пока ``h`` станет нерабочим."
