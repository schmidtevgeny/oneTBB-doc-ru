# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-03-20 18:21+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:4
msgid "Data Flow Graph"
msgstr "Граф потока данных"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:7
msgid "In a data flow graph, nodes are computations that send and receive data messages. Some nodes may only send messages, others may only receive messages, and others may send messages in response to messages that they receive."
msgstr "В графе потока данных узлы - это вычисления, которые отправляют и получают сообщения с данными. Некоторые узлы могут только отправлять сообщения, другие - только получать, а третьи - отправлять сообщения в ответ на сообщения, которые они получают."

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:13
msgid "In the following data flow graph, the left-most node generates the integer values from 1 to 10 and passes them to two successor nodes. One of the successors squares each value it receives and passes the result downstream. The second successor cubes each value it receives and passes the result downstream. The right-most node receives values from both of the middle nodes. As it receives each value, it adds it to a running sum of values. When the application is run to completion, the value of sum will be equal to the sum of the sequence of squares and cubes from 1 to 10."
msgstr "В следующем графе потока данных крайний левый узел генерирует целочисленные значения от 1 до 10 и передает их двум узлам-преемникам. Один из преемников возводит в квадрат каждое полученное значение и передает результат вниз по потоку. Второй преемник возводит в куб каждое полученное значение и передает результат вниз по потоку. Самый правый узел получает значения от обоих средних узлов. Получая каждое значение, он добавляет его к текущей сумме значений. Когда приложение будет выполнено до конца, значение суммы будет равно сумме последовательности квадратов и кубов от 1 до 10."

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:28
msgid "Simple Data Flow Graph"
msgstr "Простой граф потока данных"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:34
msgid "|image0|"
msgstr "|image0|"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:197
msgid "image0"
msgstr "image0"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:197
msgid ".. image:: main/tbb_userguide/Images/flow_graph.jpg"
msgstr ".. image:: main/tbb_userguide/Images/flow_graph.jpg"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:37
msgid "The following code snippet shows an implementation of the **Simple Data Flow Graph** shown above:"
msgstr "Следующий фрагмент кода показывает реализацию **Простого графа потока данных**, показанного выше:"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:44
msgid ""
"int sum = 0;\n"
"graph g;\n"
"function_node< int, int > squarer( g, unlimited, [](const int &v) {\n"
"    return v*v;\n"
"} );\n"
"function_node< int, int > cuber( g, unlimited, [](const int &v) {\n"
"    return v*v*v;\n"
"} );\n"
"function_node< int, int > summer( g, 1, [&](const int &v ) -> int {\n"
"    return sum += v;\n"
"} );\n"
"make_edge( squarer, summer );\n"
"make_edge( cuber, summer );\n"
"\n"
"\n"
"for ( int i = 1; i <= 10; ++i ) {\n"
"  squarer.try_put(i);\n"
"  cuber.try_put(i);\n"
"}\n"
"g.wait_for_all();\n"
"\n"
"\n"
"cout << \"Sum is \" << sum << \"\\n\";"
msgstr ""
"int sum = 0;\n"
"graph g;\n"
"function_node< int, int > squarer( g, unlimited, [](const int &v) {\n"
"    return v*v;\n"
"} );\n"
"function_node< int, int > cuber( g, unlimited, [](const int &v) {\n"
"    return v*v*v;\n"
"} );\n"
"function_node< int, int > summer( g, 1, [&](const int &v ) -> int {\n"
"    return sum += v;\n"
"} );\n"
"make_edge( squarer, summer );\n"
"make_edge( cuber, summer );\n"
"\n"
"\n"
"for ( int i = 1; i <= 10; ++i ) {\n"
"  squarer.try_put(i);\n"
"  cuber.try_put(i);\n"
"}\n"
"g.wait_for_all();\n"
"\n"
"\n"
"cout << \"Sum is \" << sum << \"\\n\";"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:69
msgid "In the implementation above, the following function_nodes are created:"
msgstr "В реализации, описанной выше, создаются следующие функциональные узлы:"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:72
msgid "one to square values"
msgstr "возведение в квадрат"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:73
msgid "one to cube values"
msgstr "возведение в куб"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:74
msgid "one to add values to the global sum"
msgstr "накопление глобальной суммы"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:77
msgid "Since the squarer and cuber nodes are side-effect free, they are created with an unlimited concurrency. The summer node updates the sum through a reference to a global variable and therefore is not safe to execute in parallel. It is therefore created with a concurrency limit of 1. The node F from **Simple Data Flow Graph** above is implemented as a loop that puts messages to both the squarer and cuber node."
msgstr "Поскольку узлы squarer и cuber не имеют побочных эффектов, они создаются с неограниченным параллелизмом. Узел summer обновляет сумму через ссылку на глобальную переменную и поэтому небезопасен для параллельного выполнения. Поэтому он создается с ограничением параллельности в 1. Узел F **простого графа потока** выше реализован как цикл, который помещает сообщения в оба узла - squarer и cuber."

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:85
msgid "A slight improvement over the first implementation is to introduce an additional node type, a ``broadcast_node``. A ``broadcast_node`` broadcasts any message it receives to all of its successors."
msgstr "Небольшим улучшением по сравнению с первой реализацией является введение дополнительного типа узла, ``broadcast_node``. Узел ``broadcast_node`` транслирует любое полученное им сообщение всем своим преемникам."

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:90
msgid "This enables replacing the two ``try_put``'s in the loop with a single ``try_put``:"
msgstr "Это позволяет заменить два ``try_put`` в цикле на один ``try_put``:"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:97
msgid ""
"broadcast_node<int> b(g);\n"
"make_edge( b, squarer );\n"
"make_edge( b, cuber );\n"
"for ( int i = 1; i <= 10; ++i ) {\n"
"  b.try_put(i);\n"
"}\n"
"g.wait_for_all();"
msgstr ""
"broadcast_node<int> b(g);\n"
"make_edge( b, squarer );\n"
"make_edge( b, cuber );\n"
"for ( int i = 1; i <= 10; ++i ) {\n"
"  b.try_put(i);\n"
"}\n"
"g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:106
msgid "An even better option, which will make the implementation even more like the **Simple Data Flow Graph** above, is to introduce an ``input_node``. An ``input_node``, as the name implies only sends messages and does not receive messages. Its constructor takes two arguments:"
msgstr "Еще лучший вариант, который сделает реализацию еще более похожей на **Simple Data Flow Graph** выше, - это ввести ``input_node``. Узел ``input_node``, как следует из названия, только посылает сообщения и не принимает их. Его конструктор принимает два аргумента:"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:115
msgid "template< typename Body > input_node( graph &g, Body body)"
msgstr "template< typename Body > input_node( graph &g, Body body)"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:117
msgid "The body is a function object, or lambda expression, that contains a function operator:"
msgstr "Тело - это объект функции, или лямбда-выражение, которое содержит оператор функции:"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:124
msgid "Output Body::operator()( oneapi::tbb::flow_control &fc );"
msgstr "Output Body::operator()( oneapi::tbb::flow_control &fc );"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:127
msgid "You can replace the loop in the example with an ``input_node``"
msgstr "Ты можешь заменить цикл в примере на ``input_node``"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:133
msgid ""
"input_node< int > src( g, src_body(10) );\n"
"make_edge( src, squarer );\n"
"make_edge( src, cuber );\n"
"src.activate();\n"
"g.wait_for_all();"
msgstr ""
"input_node< int > src( g, src_body(10) );\n"
"make_edge( src, squarer );\n"
"make_edge( src, cuber );\n"
"src.activate();\n"
"g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:140
msgid "The runtime library will repeatedly invoke the function operator in ``src_body`` until ``fc.stop()`` is invoked inside the body. You therefore need to create body that will act like the body of the loop in the **Simple Data Flow Graph** above. The final implementation after all of these changes is shown below:"
msgstr "Библиотека времени выполнения будет неоднократно вызывать оператор функции в ``src_body`` до тех пор, пока ``sfc.stop()`` не будет вызван внутри тела. Поэтому тебе нужно создать тело, которое будет действовать подобно телу цикла в **Простой схеме потока данных** выше. Окончательная реализация после всех этих изменений показана ниже:"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:150
msgid ""
"class src_body {\n"
"    const int my_limit;\n"
"    int my_next_value;\n"
"public:\n"
"    src_body(int l) : my_limit(l), my_next_value(1) {}\n"
"    int operator()( oneapi::tbb::flow_control& fc ) {\n"
"        if ( my_next_value <= my_limit ) {\n"
"            return my_next_value++;\n"
"        } else {\n"
"            fc.stop();\n"
"            return int();\n"
"        }\n"
"    }\n"
"};\n"
"\n"
"\n"
"int main() {\n"
"  int sum = 0;\n"
"  graph g;\n"
"  function_node< int, int > squarer( g, unlimited, [](const int &v) {\n"
"      return v*v;\n"
"  } );\n"
"  function_node< int, int > cuber( g, unlimited, [](const int &v) {\n"
"      return v*v*v;\n"
"  } );\n"
"  function_node< int, int > summer( g, 1, [&](const int &v ) -> int {\n"
"      return sum += v;\n"
"  } );\n"
"  make_edge( squarer, summer );\n"
"  make_edge( cuber, summer );\n"
"  input_node< int > src( g, src_body(10) );\n"
"  make_edge( src, squarer );\n"
"  make_edge( src, cuber );\n"
"  src.activate();\n"
"  g.wait_for_all();\n"
"  cout << \"Sum is \" << sum << \"\\n\";\n"
"}"
msgstr ""
"class src_body {\n"
"    const int my_limit;\n"
"    int my_next_value;\n"
"public:\n"
"    src_body(int l) : my_limit(l), my_next_value(1) {}\n"
"    int operator()( oneapi::tbb::flow_control& fc ) {\n"
"        if ( my_next_value <= my_limit ) {\n"
"            return my_next_value++;\n"
"        } else {\n"
"            fc.stop();\n"
"            return int();\n"
"        }\n"
"    }\n"
"};\n"
"\n"
"\n"
"int main() {\n"
"  int sum = 0;\n"
"  graph g;\n"
"  function_node< int, int > squarer( g, unlimited, [](const int &v) {\n"
"      return v*v;\n"
"  } );\n"
"  function_node< int, int > cuber( g, unlimited, [](const int &v) {\n"
"      return v*v*v;\n"
"  } );\n"
"  function_node< int, int > summer( g, 1, [&](const int &v ) -> int {\n"
"      return sum += v;\n"
"  } );\n"
"  make_edge( squarer, summer );\n"
"  make_edge( cuber, summer );\n"
"  input_node< int > src( g, src_body(10) );\n"
"  make_edge( src, squarer );\n"
"  make_edge( src, cuber );\n"
"  src.activate();\n"
"  g.wait_for_all();\n"
"  cout << \"Sum is \" << sum << \"\\n\";\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/Data_Flow_Graph.rst:189
msgid "This final implementation has all of the nodes and edges from the **Simple Data Flow Graph** above. In this simple example, there is not much advantage in using an ``input_node`` over an explicit loop. But, because an ``input_node`` is able to react to the behavior of downstream nodes, it can limit memory use in more complex graphs. For more information, see:ref:`create_token_based_system` ."
msgstr "Эта окончательная реализация имеет все узлы и ребра из **Простого графика потока данных**, приведенного выше. В этом простом примере нет большого преимущества в использовании ``input_node`` по сравнению с явным циклом. Но, поскольку ``input_node`` способен реагировать на поведение нижележащих узлов, он может ограничить использование памяти в более сложных графах. Для получения дополнительной информации смотри :ref:`create_token_based_system`."
