# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-04-24 20:08+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:4
msgid "concurrent_hash_map"
msgstr "concurrent_hash_map"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:7
msgid "A ``concurrent_hash_map<Key, T, HashCompare >`` is a hash table that permits concurrent accesses. The table is a map from a key to a type ``T``. The traits type HashCompare defines how to hash a key and how to compare two keys."
msgstr "``concurrent_hash_map<Key, T, HashCompare >`` - это хэш-таблица, которая допускает одновременный доступ. Таблица представляет собой карту от ключа к типу ``T``. Тип признаков HashCompare определяет, как хэшировать ключ и как сравнивать два ключа."

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:13
msgid "The following example builds a ``concurrent_hash_map`` where the keys are strings and the corresponding data is the number of times each string occurs in the array ``Data``."
msgstr "Следующий пример строит ``concurrent_hash_map``, где ключами являются строки, а соответствующими данными - количество раз, когда каждая строка встречается в массиве ``Data``."

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:21
#, python-format
msgid ""
"#include \"oneapi/tbb/concurrent_hash_map.h\"\n"
"#include \"oneapi/tbb/blocked_range.h\"\n"
"#include \"oneapi/tbb/parallel_for.h\"\n"
"#include <string>\n"
"\n"
"\n"
"using namespace oneapi::tbb;\n"
"using namespace std;\n"
"\n"
"\n"
"// Structure that defines hashing and comparison operations for user's type.\n"
"struct MyHashCompare {\n"
"    static size_t hash( const string& x ) {\n"
"        size_t h = 0;\n"
"        for( const char* s = x.c_str(); *s; ++s )\n"
"            h = (h*17)^*s;\n"
"        return h;\n"
"    }\n"
"    //! True if strings are equal\n"
"    static bool equal( const string& x, const string& y ) {\n"
"        return x==y;\n"
"    }\n"
"};\n"
"\n"
"\n"
"// A concurrent hash table that maps strings to ints.\n"
"typedef concurrent_hash_map<string,int,MyHashCompare> StringTable;\n"
"\n"
"\n"
"// Function object for counting occurrences of strings.\n"
"struct Tally {\n"
"    StringTable& table;\n"
"    Tally( StringTable& table_ ) : table(table_) {}\n"
"    void operator()( const blocked_range<string*> range ) const {\n"
"        for( string* p=range.begin(); p!=range.end(); ++p ) {\n"
"            StringTable::accessor a;\n"
"            table.insert( a, *p );\n"
"            a->second += 1;\n"
"        }\n"
"    }\n"
"};\n"
"\n"
"\n"
"const size_t N = 1000000;\n"
"\n"
"\n"
"string Data[N];\n"
"\n"
"\n"
"void CountOccurrences() {\n"
"    // Construct empty table.\n"
"    StringTable table;\n"
"\n"
"\n"
"    // Put occurrences into the table\n"
"    parallel_for( blocked_range<string*>( Data, Data+N, 1000 ),\n"
"                  Tally(table) );\n"
"\n"
"\n"
"    // Display the occurrences\n"
"    for( StringTable::iterator i=table.begin(); i!=table.end(); ++i )\n"
"        printf(\"%s %d\\n\",i->first.c_str(),i->second);\n"
"}"
msgstr ""
"#include \"oneapi/tbb/concurrent_hash_map.h\"\n"
"#include \"oneapi/tbb/blocked_range.h\"\n"
"#include \"oneapi/tbb/parallel_for.h\"\n"
"#include <string>\n"
"\n"
"\n"
"using namespace oneapi::tbb;\n"
"using namespace std;\n"
"\n"
"\n"
"// Структура, определяющая операции хэширования и сравнения для типа пользователя.\n"
"struct MyHashCompare {\n"
"    static size_t hash( const string& x ) {\n"
"        size_t h = 0;\n"
"        for( const char* s = x.c_str(); *s; ++s )\n"
"            h = (h*17)^*s;\n"
"        return h;\n"
"    }\n"
"    //! Истина, если строки равны\n"
"    static bool equal( const string& x, const string& y ) {\n"
"        return x==y;\n"
"    }\n"
"};\n"
"\n"
"\n"
"// Параллельная хэш-таблица, которая отображает строки на инты.\n"
"typedef concurrent_hash_map<string,int,MyHashCompare> StringTable;\n"
"\n"
"\n"
"// Объект функции для подсчета вхождений строк.\n"
"struct Tally {\n"
"    StringTable& table;\n"
"    Tally( StringTable& table_ ) : table(table_) {}\n"
"    void operator()( const blocked_range<string*> range ) const {\n"
"        for( string* p=range.begin(); p!=range.end(); ++p ) {\n"
"            StringTable::accessor a;\n"
"            table.insert( a, *p );\n"
"            a->second += 1;\n"
"        }\n"
"    }\n"
"};\n"
"\n"
"\n"
"const size_t N = 1000000;\n"
"\n"
"\n"
"string Data[N];\n"
"\n"
"\n"
"void CountOccurrences() {\n"
"    // Постройте пустую таблицу.\n"
"    StringTable table;\n"
"\n"
"\n"
"    // Занесите вхождения в таблицу\n"
"    parallel_for( blocked_range<string*>( Data, Data+N, 1000 ),\n"
"                  Tally(table) );\n"
"\n"
"\n"
"    // Отображение вхождений\n"
"    for( StringTable::iterator i=table.begin(); i!=table.end(); ++i )\n"
"        printf(\"%s %d\\n\",i->first.c_str(),i->second);\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:86
msgid "A ``concurrent_hash_map`` acts as a container of elements of type ``std::pair<const Key,T>``. Typically, when accessing a container element, you are interested in either updating it or reading it. The template class ``concurrent_hash_map`` supports these two purposes respectively with the classes ``accessor`` and ``const_accessor`` that act as smart pointers. An *accessor* represents *update* (*write*) access. As long as it points to an element, all other attempts to look up that key in the table block until the ``accessor`` is done. A ``const_accessor`` is similar, except that is represents *read-only* access. Multiple ``const_accessors`` can point to the same element at the same time. This feature can greatly improve concurrency in situations where elements are frequently read and infrequently updated."
msgstr "Карта ``concurrent_hash_map`` действует как контейнер элементов типа ``std::pair<const Key,T>``. Как правило, при обращении к элементу контейнера тебя интересует либо его обновление, либо чтение. Шаблонный класс ``concurrent_hash_map`` поддерживает эти две цели соответственно с помощью классов ``accessor`` и ``const_accessor``, которые действуют как умные указатели. *Аксессор* представляет собой доступ к *обновлению* (*записи*). Пока он указывает на элемент, все остальные попытки поиска этого ключа в таблице блокируются до тех пор, пока не завершится работа ``accessor``. Аналогично действует ``const_accessor``, за исключением того, что он представляет доступ *только для чтения*. Несколько ``const_accessor`` могут одновременно указывать на один и тот же элемент. Эта возможность может значительно улучшить параллелизм в ситуациях, когда элементы часто читаются и нечасто обновляются."

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:100
msgid "The methods ``find`` and ``insert`` take an ``accessor`` or ``const_accessor`` as an argument. The choice tells ``concurrent_hash_map`` whether you are asking for *update* or *read-only* access. Once the method returns, the access lasts until the ``accessor`` or ``const_accessor`` is destroyed. Because having access to an element can block other threads, try to shorten the lifetime of the ``accessor`` or ``const_accessor``. To do so, declare it in the innermost block possible. To release access even sooner than the end of the block, use method ``release``. The following example is a rework of the loop body that uses ``release`` instead of depending upon destruction to end thread lifetime:"
msgstr "Методы ``find`` и ``insert`` принимают в качестве аргумента ``accessor`` или ``const_accessor``. Выбор говорит ``concurrent_hash_map`` о том, запрашиваешь ли ты доступ *update* или *read-only*. Когда метод возвращается, доступ длится до тех пор, пока ``accessor`` или ``const_accessor`` не будут уничтожены. Поскольку доступ к элементу может блокировать другие потоки, постарайся сократить время жизни ``accessor`` или ``const_accessor``. Для этого объяви его в самом внутреннем блоке, который только возможен. Чтобы освободить доступ даже раньше конца блока, используй метод ``release``. Следующий пример представляет собой переработку тела цикла, в котором используется ``release`` вместо того, чтобы зависеть от уничтожения для завершения времени жизни потока:"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:116
msgid ""
"StringTable accessor a;\n"
"for( string* p=range.begin(); p!=range.end(); ++p ) {\n"
"    table.insert( a, *p );\n"
"    a->second += 1;\n"
"    a.release();\n"
"}"
msgstr ""
"StringTable accessor a;\n"
"for( string* p=range.begin(); p!=range.end(); ++p ) {\n"
"    table.insert( a, *p );\n"
"    a->second += 1;\n"
"    a.release();\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_hash_map.rst:124
msgid "The method ``remove(key)`` can also operate concurrently. It implicitly requests write access. Therefore before removing the key, it waits on any other extant accesses on ``key``."
msgstr "Метод ``remove(key)`` также может работать параллельно. Он неявно запрашивает доступ на запись. Поэтому перед тем, как удалить ключ, он ожидает любых других существующих обращений к ``key``."
