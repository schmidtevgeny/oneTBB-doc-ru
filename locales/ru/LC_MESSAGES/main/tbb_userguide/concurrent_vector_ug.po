# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-04-24 20:15+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:4
msgid "concurrent_vector"
msgstr "concurrent_vector"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:7
msgid "``A concurrent_vector<T>`` is a dynamically growable array of ``T``. It is safe to grow a ``concurrent_vector`` while other threads are also operating on elements of it, or even growing it themselves. For safe concurrent growing, ``concurrent_vector`` has three methods that support common uses of dynamic arrays: ``push_back``, ``grow_by``, and ``grow_to_at_least``."
msgstr "``concurrent_vector<T>`` - это динамически расширяемый массив ``T``. Безопасно увеличивает ``concurrent_vector``, пока другие потоки также работают с его элементами или даже сами увеличивают его. Для безопасного параллельного роста у ``concurrent_vector`` есть три метода, которые поддерживают распространенные способы использования динамических массивов: ``push_back``, ``grow_by`` и ``grow_to_at_least``."

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:15
msgid "Method ``push_back(x)`` safely appends x to the array. Method ``grow_by(n)`` safely appends ``n`` consecutive elements initialized with ``T()``. Both methods return an iterator pointing to the first appended element. Each element is initialized with ``T()``. So for example, the following routine safely appends a C string to a shared vector:"
msgstr "Метод ``push_back(x)`` безопасно добавляет x в массив. Метод ``grow_by(n)`` безопасно добавляет ``n`` последовательных элементов, инициализированных ``T()``. Оба метода возвращают итератор, указывающий на первый добавленный элемент. Каждый элемент инициализируется значением ``T()``. Так, например, следующая процедура безопасно добавляет строку C в общий вектор:"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:26
msgid ""
"void Append( concurrent_vector<char>& vector, const char* string ) {\n"
"    size_t n = strlen(string)+1;\n"
"    std::copy( string, string+n, vector.grow_by(n) );\n"
"}"
msgstr ""
"void Append( concurrent_vector<char>& vector, const char* string ) {\n"
"    size_t n = strlen(string)+1;\n"
"    std::copy( string, string+n, vector.grow_by(n) );\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:32
msgid "The related method ``grow_to_at_least(n)``\\ grows a vector to size ``n`` if it is shorter. Concurrent calls to the growth methods do not necessarily return in the order that elements are appended to the vector."
msgstr "Связанный метод ``grow_to_at_least(n)`` увеличивает вектор до размера ``n``, если он короче. Одновременные вызовы методов роста не обязательно возвращаются в том порядке, в котором элементы добавляются к вектору."

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:38
msgid "Method ``size()`` returns the number of elements in the vector, which may include elements that are still undergoing concurrent construction by methods ``push_back``, ``grow_by,`` or ``grow_to_at_least``. The example uses std::copy and iterators, not ``strcpy and pointers``, because elements in a ``concurrent_vector`` might not be at consecutive addresses. It is safe to use the iterators while the ``concurrent_vector`` is being grown, as long as the iterators never go past the current value of ``end()``. However, the iterator may reference an element undergoing concurrent construction. You must synchronize construction and access."
msgstr "Метод ``size()`` возвращает количество элементов в векторе, который может включать элементы, находящиеся в процессе параллельного построения методами ``push_back``, ``grow_by`` или ``grow_to_at_least``. В примере используются std::copy и итераторы, а не ``strcpy`` и указатели, потому что элементы в ``concurrent_vector`` могут находиться не по последовательным адресам. Безопасно использовать итераторы во время роста ``concurrent_vector``, пока итераторы никогда не выходят за пределы текущего значения ``end()``. Однако итератор может ссылаться на элемент, находящийся в процессе одновременного построения. Ты должен синхронизировать построение и доступ."

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:50
msgid "A ``concurrent_vector<T>`` never moves an element until the array is cleared, which can be an advantage over the STL std::vector even for single-threaded code. However, ``concurrent_vector`` does have more overhead than std::vector. Use ``concurrent_vector`` only if you really need the ability to dynamically resize it while other accesses are (or might be) in flight, or require that an element never move."
msgstr "``concurrent_vector<T>`` никогда не перемещает элемент, пока массив не будет очищен, что может быть преимуществом перед STL std::vector даже для однопоточного кода. Однако ``concurrent_vector`` имеет больше накладных расходов, чем std::vector. Используй ``concurrent_vector`` только в том случае, если тебе действительно нужна возможность динамически изменять его размер, пока другие доступы находятся (или могут находиться) в полете, или требуется, чтобы элемент никогда не перемещался."

#: ../../oneTBB/doc/main/tbb_userguide/concurrent_vector_ug.rst:59
msgid "Operations on ``concurrent_vector`` are concurrency safe with respect to *growing*, not for clearing or destroying a vector. Never invoke method ``clear()`` if there are other operations in flight on the ``concurrent_vector``."
msgstr "Операции над ``concurrent_vector`` являются параллельно безопасными в отношении *возрастания*, но не для очистки или уничтожения вектора. Никогда не вызывай метод ``clear()``, если над ``concurrent_vector`` выполняются другие операции."
