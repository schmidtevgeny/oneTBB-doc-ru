# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-04-24 21:20+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/UpgradeDowngrade.rst:4
msgid "Upgrade/Downgrade"
msgstr "Обновление/понижение"

#: ../../oneTBB/doc/main/tbb_userguide/UpgradeDowngrade.rst:7
msgid "It is possible to upgrade a reader lock to a writer lock, by using the method ``upgrade_to_writer``. Here is an example."
msgstr "Можно повысить блокировку читателя до блокировки писателя, используя метод ``upgrade_to_writer``. Вот пример."

#: ../../oneTBB/doc/main/tbb_userguide/UpgradeDowngrade.rst:14
msgid ""
"std::vector<string> MyVector;\n"
"typedef spin_rw_mutex MyVectorMutexType;\n"
"MyVectorMutexType MyVectorMutex;\n"
"\n"
"\n"
"void AddKeyIfMissing( const string& key ) {\n"
"    // Obtain a reader lock on MyVectorMutex\n"
"    MyVectorMutexType::scoped_lock lock(MyVectorMutex,/*is_writer=*/false);\n"
"    size_t n = MyVector.size();\n"
"    for( size_t i=0; i<n; ++i )\n"
"        if( MyVector[i]==key ) return;\n"
"    if( !lock.upgrade_to_writer() )\n"
"        // Check if key was added while lock was temporarily released\n"
"        for( int i=n; i<MyVector.size(); ++i )\n"
"           if(MyVector[i]==key ) return;\n"
"    vector.push_back(key);\n"
"}"
msgstr ""
"std::vector<string> MyVector;\n"
"typedef spin_rw_mutex MyVectorMutexType;\n"
"MyVectorMutexType MyVectorMutex;\n"
"\n"
"\n"
"void AddKeyIfMissing( const string& key ) {\n"
"    // Obtain a reader lock on MyVectorMutex\n"
"    MyVectorMutexType::scoped_lock lock(MyVectorMutex,/*is_writer=*/false);\n"
"    size_t n = MyVector.size();\n"
"    for( size_t i=0; i<n; ++i )\n"
"        if( MyVector[i]==key ) return;\n"
"    if( !lock.upgrade_to_writer() )\n"
"        // Check if key was added while lock was temporarily released\n"
"        for( int i=n; i<MyVector.size(); ++i )\n"
"           if(MyVector[i]==key ) return;\n"
"    vector.push_back(key);\n"
"}"

#: ../../oneTBB/doc/main/tbb_userguide/UpgradeDowngrade.rst:33
msgid "Note that the vector must sometimes be searched again. This is necessary because ``upgrade_to_writer`` might have to temporarily release the lock before it can upgrade. Otherwise, deadlock might ensue, as discussed in **Lock Pathologies**. Method ``upgrade_to_writer`` returns a ``bool`` that is true if it successfully upgraded the lock without releasing it, and false if the lock was released temporarily. Thus when ``upgrade_to_writer`` returns false, the code must rerun the search to check that the key was not inserted by another writer. The example presumes that keys are always added to the end of the vector, and that keys are never removed. Because of these assumptions, it does not have to re-search the entire vector, but only the elements beyond those originally searched. The key point to remember is that when ``upgrade_to_writer`` returns false, any assumptions established while holding a reader lock may have been invalidated, and must be rechecked."
msgstr "Обрати внимание, что иногда вектор нужно искать снова. Это необходимо, потому что ``upgrade_to_writer`` может потребоваться временно снять блокировку, прежде чем он сможет выполнить обновление. В противном случае может возникнуть тупик, о котором говорилось в **Патологии блокировки**. Метод ``upgrade_to_writer`` возвращает ``bool``, который равен true, если он успешно обновил блокировку, не освобождая её, и false, если блокировка была временно освобождена. Таким образом, когда ``upgrade_to_writer`` возвращает false, код должен повторно запустить поиск, чтобы проверить, что ключ не был вставлен другим автором. В примере предполагается, что ключи всегда добавляются в конец вектора, и что ключи никогда не удаляются. Из-за этих предположений не нужно заново искать весь вектор, а только те элементы, которые находятся за пределами первоначального поиска. Главное помнить, что когда ``upgrade_to_writer`` возвращает false, все предположения, установленные во время удержания блокировки считывателя, могут быть недействительными, и их необходимо перепроверить."

#: ../../oneTBB/doc/main/tbb_userguide/UpgradeDowngrade.rst:49
msgid "For symmetry, there is a corresponding method ``downgrade_to_reader``, though in practice there are few reasons to use it."
msgstr "Для симметрии существует соответствующий метод ``downgrade_to_reader``, хотя на практике причин для его использования немного."
