# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 14:48+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Edges.rst:4
msgid "Flow Graph Basics: Edges"
msgstr "Основы графа потока: Грани"

#: ../../oneTBB/doc/main/tbb_userguide/Edges.rst:7
msgid "Most applications contain multiple nodes with edges connecting them to each other. In the flow graph interface, edges are directed channels over which messages are passed. They are created by calling the function ``make_edge( p, s )`` with two arguments: ``p``, the predecessor, and ``s``, the successor. You can modify the example used in the **Nodes** topic to include a second node that squares the value it receives before printing it and then connect that to the first node with an edge."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Edges.rst:19
msgid ""
"graph g;\n"
"function_node< int, int > n( g, unlimited, []( int v ) -> int {\n"
"    cout << v;\n"
"    spin_for( v );\n"
"    cout << v;\n"
"    return v;\n"
"} );\n"
"function_node< int, int > m( g, 1, []( int v ) -> int {\n"
"    v *= v;\n"
"    cout << v;\n"
"    spin_for( v );\n"
"    cout << v;\n"
"    return v;\n"
"} );\n"
"make_edge( n, m );\n"
"n.try_put( 1 );\n"
"n.try_put( 2 );\n"
"n.try_put( 3 );\n"
"g.wait_for_all();"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Edges.rst:40
msgid "Now there are two ``function_node``s, ``n`` and ``m``. The call to ``make_edge`` creates an edge from ``n`` to ``m``. The node n is created with unlimited concurrency, while ``m`` has a concurrency limit of 1. The invocations of ``n`` can all proceed in parallel, while the invocations of ``m`` will be serialized. Because there is an edge from ``n`` to ``m``, each value ``v``, returned by ``n``, will be automatically passed to node ``m`` by the runtime library."
msgstr ""
