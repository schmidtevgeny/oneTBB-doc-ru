# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-02-24 14:49+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:4
msgid "Flow Graph Basics: Mapping Nodes to Tasks"
msgstr "Основы графа потока: Сопоставление узлов с задачами"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:7
msgid "The following figure shows the timeline for one possible execution of the two node graph example in the previous section. The bodies of n and m will be referred to as λ\\ :sub:`n` and λ\\ :sub:`m`, respectively. The three calls to try_put spawn three tasks; each one applies the lambda expression, λ\\ :sub:`n`, on one of the three input messages. Because n has unlimited concurrency, these tasks can execute concurrently if there are enough threads available. The call to ``g.wait_for_all()`` blocks until there are no tasks executing in the graph. As with other ``wait_for_all`` functions in oneTBB, the thread that calls ``wait_for_all`` is not spinning idly during this time, but instead can join in executing other tasks from the work pool."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:23
msgid "**Execution Timeline of a Two Node Graph**"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:29
msgid "|image0|"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:56
msgid "image0"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:56
msgid ".. image:: main/tbb_userguide/Images/execution_timeline2node.jpg"
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:32
msgid "As each task from n finishes, it puts its output to m, since m is a successor of n. Unlike node n, m has been constructed with a concurrency limit of 1 and therefore does not spawn all tasks immediately. Instead, it sequentially spawns tasks to execute its body, λ\\ :sub:`m`, on the messages in the order that they arrive. When all tasks are complete, the call to ``wait_for_all`` returns."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:41
msgid "All execution in the flow graph happens asynchronously. The calls to try_put return control to the calling thread quickly, after either immediately spawning a task or buffering the message being passed. Likewise, the body tasks execute the lambda expressions and then put the result to any successor nodes. Only the call to ``wait_for_all`` blocks, as it should, and even in this case the calling thread may be used to execute tasks from the oneTBB work pool while it is waiting."
msgstr ""

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:50
msgid "The above timeline shows the sequence when there are enough threads to execute all of the tasks that can be executed in parallel. If there are fewer threads, some spawned tasks will need to wait until a thread is available to execute them."
msgstr ""
