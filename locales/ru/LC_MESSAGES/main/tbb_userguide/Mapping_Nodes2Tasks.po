# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-03-11 23:57+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:4
msgid "Flow Graph Basics: Mapping Nodes to Tasks"
msgstr "Основы графа потока: Сопоставление узлов с задачами"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:7
msgid "The following figure shows the timeline for one possible execution of the two node graph example in the previous section. The bodies of n and m will be referred to as λ\\ :sub:`n` and λ\\ :sub:`m`, respectively. The three calls to try_put spawn three tasks; each one applies the lambda expression, λ\\ :sub:`n`, on one of the three input messages. Because n has unlimited concurrency, these tasks can execute concurrently if there are enough threads available. The call to ``g.wait_for_all()`` blocks until there are no tasks executing in the graph. As with other ``wait_for_all`` functions in oneTBB, the thread that calls ``wait_for_all`` is not spinning idly during this time, but instead can join in executing other tasks from the work pool."
msgstr "На следующем рисунке показана временная шкала для одного возможного выполнения примера графа с двумя узлами из предыдущего раздела. Тела n и m будут обозначаться как λ\\ :sub:`n` и λ\\ :sub:`m`, соответственно. Три вызова try_put порождают три задачи; каждая из них применяет лямбда-выражение λ\\ :sub:`n` к одному из трёх входных сообщений. Поскольку n имеет неограниченный параллелизм, эти задачи могут выполняться параллельно, если имеется достаточно потоков. Вызов ``g.wait_for_all()`` блокируется до тех пор, пока в графе не останется ни одной выполняющейся задачи. Как и в других функциях ``wait_for_all`` в oneTBB, поток, вызывающий ``wait_for_all``, не крутится вхолостую в течение этого времени, а может присоединиться к выполнению других задач из пула работ."

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:23
msgid "**Execution Timeline of a Two Node Graph**"
msgstr "**Временная шкала выполнения графа с двумя узлами**"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:29
msgid "|image0|"
msgstr "|image0|"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:56
msgid "image0"
msgstr "image0"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:56
msgid ".. image:: main/tbb_userguide/Images/execution_timeline2node.jpg"
msgstr ".. image:: main/tbb_userguide/Images/execution_timeline2node.jpg"

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:32
msgid "As each task from n finishes, it puts its output to m, since m is a successor of n. Unlike node n, m has been constructed with a concurrency limit of 1 and therefore does not spawn all tasks immediately. Instead, it sequentially spawns tasks to execute its body, λ\\ :sub:`m`, on the messages in the order that they arrive. When all tasks are complete, the call to ``wait_for_all`` returns."
msgstr "Когда каждая задача из n завершается, она помещает свой вывод в m, поскольку m является преемником n. В отличие от узла n, узел m был построен с ограничением параллелизма 1, и поэтому он не порождает все задачи сразу. Вместо этого он последовательно порождает задачи для выполнения своего тела, λ\\ :sub:`m`, на сообщениях в порядке их поступления. Когда все задачи завершены, вызов ``wait_for_all`` завершается."

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:41
msgid "All execution in the flow graph happens asynchronously. The calls to try_put return control to the calling thread quickly, after either immediately spawning a task or buffering the message being passed. Likewise, the body tasks execute the lambda expressions and then put the result to any successor nodes. Only the call to ``wait_for_all`` blocks, as it should, and even in this case the calling thread may be used to execute tasks from the oneTBB work pool while it is waiting."
msgstr "Все выполнение в графе потока происходит асинхронно. Вызовы try_put быстро возвращают управление вызывающему потоку, после того как либо сразу порождают задачу, либо буферизируют передаваемое сообщение. Аналогично, тела задачи выполняют лямбда-выражения, а затем помещают результат в любые узлы-преемники. Только вызов ``wait_for_all`` блокируется, как и должно быть, и даже в этом случае вызывающий поток может использоваться для выполнения задач из пула работ oneTBB во время ожидания."

#: ../../oneTBB/doc/main/tbb_userguide/Mapping_Nodes2Tasks.rst:50
msgid "The above timeline shows the sequence when there are enough threads to execute all of the tasks that can be executed in parallel. If there are fewer threads, some spawned tasks will need to wait until a thread is available to execute them."
msgstr "На приведенной выше временной шкале показана последовательность, когда потоков достаточно для выполнения всех задач, которые могут выполняться параллельно. Если потоков меньше, то некоторым порожденным задачам придется подождать, пока освободится поток для их выполнения."
