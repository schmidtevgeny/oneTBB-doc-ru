# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: oneTBB\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: 2022-03-20 19:12+0300\n"
"Last-Translator: Evgeny <schmidte@list.ru>\n"
"Language-Team: \n"
"Language: ru_RU\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : 2);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../oneTBB/doc/main/tbb_userguide/use_concurrency_limits.rst:4
msgid "Use Concurrency Limits"
msgstr "Использование пределов параллелизма"

#: ../../oneTBB/doc/main/tbb_userguide/use_concurrency_limits.rst:7
msgid "To control the number of instances of a single node, you can use the concurrency limit on the node. To cause it to reject messages after it reaches its concurrency limit, you construct it as a \"rejecting\" node."
msgstr "Чтобы контролировать количество экземпляров одного узла, ты можешь использовать предел параллелизма узла. Чтобы заставить его отклонять сообщения после достижения предела параллелизма, ты конструируешь его как \"отклоняющий\" узел."

#: ../../oneTBB/doc/main/tbb_userguide/use_concurrency_limits.rst:12
msgid "A function node is constructed with one or more template arguments. The third argument controls the buffer policy used by the node, and is by default queueing. With a queueing policy, a ``function_node`` that has reached its concurrency limit still accepts incoming messages, but buffers them internally. If the policy is set to rejecting the node will instead reject the incoming messages."
msgstr "Функциональный узел строится с одним или несколькими аргументами шаблона. Третий аргумент управляет политикой буферизации, используемой узлом, и по умолчанию это политика постановки в очередь. При политике очередей ``function_node``, достигший своего предела параллелизма, по-прежнему принимает входящие сообщения, но буферизирует их внутри себя. Если политика установлена на отклонение, то вместо этого узел будет отклонять входящие сообщения."

#: ../../oneTBB/doc/main/tbb_userguide/use_concurrency_limits.rst:23
msgid ""
"template < typename Input,\n"
"           typename Output = continue_msg,\n"
"           graph_buffer_policy = queueing >\n"
"class function_node;"
msgstr ""
"template < typename Input,\n"
"           typename Output = continue_msg,\n"
"           graph_buffer_policy = queueing >\n"
"class function_node;"

#: ../../oneTBB/doc/main/tbb_userguide/use_concurrency_limits.rst:29
msgid "For example, you can control the number of big objects in flight in a graph by placing a rejecting function_node downstream of an ``input_node``, as is done below:"
msgstr "Например, ты можешь контролировать количество больших объектов в полете в графе, разместив отвергающую function_node ниже по течению от ``input_node``, как это сделано ниже:"

#: ../../oneTBB/doc/main/tbb_userguide/use_concurrency_limits.rst:37
msgid ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"function_node< big_object *, continue_msg, rejecting > f( g, 3,\n"
"    []( big_object *v ) -> continue_msg {\n"
"    spin_for(1);\n"
"       delete v;\n"
"    return continue_msg();\n"
"} );\n"
"\n"
"\n"
"make_edge( s, f );\n"
"g.wait_for_all();"
msgstr ""
"graph g;\n"
"\n"
"\n"
"int src_count = 0;\n"
"int number_of_objects = 0;\n"
"int max_objects = 3;\n"
"\n"
"\n"
"input_node< big_object * > s( g, [&]( oneapi::tbb::flow_control& fc ) -> big_object* {\n"
"    if ( src_count < M ) {\n"
"      big_object* v = new big_object();\n"
"      ++src_count;\n"
"      return v;\n"
"    } else {\n"
"      fc.stop();\n"
"      return nullptr;\n"
"    }\n"
"} );\n"
"s.activate();\n"
"\n"
"function_node< big_object *, continue_msg, rejecting > f( g, 3,\n"
"    []( big_object *v ) -> continue_msg {\n"
"    spin_for(1);\n"
"       delete v;\n"
"    return continue_msg();\n"
"} );\n"
"\n"
"\n"
"make_edge( s, f );\n"
"g.wait_for_all();"

#: ../../oneTBB/doc/main/tbb_userguide/use_concurrency_limits.rst:69
msgid "The ``function_node`` will operate on at most three big objects concurrently. The node's concurrency threshold that limits the node to three concurrent invocations. When the ``function_node`` is running three instances concurrently, it will start rejecting incoming messages from the ``input_node``, causing the ``input_node`` to buffer its last created object and temporarily stop invoking its body object. Whenever the ``function_node`` drops below its concurrency limit, it will pull new messages from the ``input_node``. At most four big objects will exist simultaneously, three in the ``function_node`` and one buffered in the ``input_node``."
msgstr "Узел ``function_node`` будет оперировать не более чем тремя большими объектами одновременно. Порог параллелизма узла, который ограничивает узел тремя одновременными вызовами. Когда ``function_node`` будет выполнять три одновременных экземпляра, она начнёт отклонять входящие сообщения от ``input_node``, заставляя ``input_node`` буферизировать свой последний созданный объект и временно прекращать вызовы своего объекта body. Всякий раз, когда ``function_node`` опускается ниже своего предела параллелизма, она будет получать новые сообщения от ``input_node``. Максимум четыре больших объекта будут существовать одновременно, три в ``function_node`` и один буферизованный в ``input_node``."
