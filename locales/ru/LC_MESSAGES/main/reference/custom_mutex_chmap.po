# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Intel Corporation
# This file is distributed under the same license as the oneTBB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: oneTBB \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:08+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:4
msgid "The customizing mutex type for ``concurrent_hash_map``"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:7
msgid ""
"To enable this feature, define the "
"``TBB_PREVIEW_CONCURRENT_HASH_MAP_EXTENSIONS`` macro to 1."
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:14
msgid "Description"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:16
msgid ""
"oneTBB ``concurrnent_hash_map`` class uses reader-writer mutex to provide"
" thread safety and avoid data races for insert, lookup, and erasure "
"operations. This feature adds an extra template parameter for "
"``concurrent_hash_map`` that allows to customize the type of the reader-"
"writer mutex."
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:21
msgid "API"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:24
msgid "Header"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:26
msgid "#include <oneapi/tbb/concurrent_hash_map.h>"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:31
msgid "Synopsis"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:33
msgid ""
"namespace oneapi {\n"
"namespace tbb {\n"
"\n"
"    template <typename Key, typename T,\n"
"            typename HashCompare = tbb_hash_compare<Key>,\n"
"            typename Allocator = tbb_allocator<std::pair<const Key, T>>,\n"
"            typename Mutex = spin_rw_mutex>\n"
"    class concurrent_hash_map {\n"
"        using mutex_type = Mutex;\n"
"    };\n"
"\n"
"} // namespace tbb\n"
"} // namespace oneapi"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:50
msgid "Type requirements"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:52
msgid ""
"The type of the mutex passed as a template argument for "
"``concurrent_hash_map`` should meet the requirements of "
"`ReaderWriterMutex "
"<https://spec.oneapi.com/versions/latest/elements/oneTBB/source/named_requirements/mutexes/rw_mutex.html>`_."
" It should also provide the following API:"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:58
msgid ""
"**Returns**: ``true`` if the ``scoped_lock`` object acquires the mutex as"
" a writer, ``false`` otherwise."
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:60
msgid ""
"The behavior is undefined if the ``scoped_lock`` object does not acquire "
"the mutex."
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:62
msgid ""
"``oneapi::tbb::spin_rw_mutex``, "
"``oneapi::tbb::speculative_spin_rw_mutex``, "
"``oneapi::tbb::queuing_rw_mutex``, ``oneapi::tbb::null_rw_mutex``, and "
"``oneapi::tbb::rw_mutex`` meet the requirements above."
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:66
msgid "Example"
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:67
msgid ""
"The example below demonstrates how to wrap ``std::shared_mutex`` (C++17) "
"to meet the requirements of `ReaderWriterMutex` and how to customize "
"``concurrent_hash_map`` to use this mutex."
msgstr ""

#: ../../oneTBB/doc/main/reference/custom_mutex_chmap.rst:70
msgid ""
"#define TBB_PREVIEW_CONCURRENT_HASH_MAP_EXTENSIONS 1\n"
"#include \"oneapi/tbb/concurrent_hash_map.h\"\n"
"#include <shared_mutex>\n"
"\n"
"class SharedMutexWrapper {\n"
"public:\n"
"    // ReaderWriterMutex requirements\n"
"\n"
"    static constexpr bool is_rw_mutex = true;\n"
"    static constexpr bool is_recursive_mutex = false;\n"
"    static constexpr bool is_fair_mutex = false;\n"
"\n"
"    class scoped_lock {\n"
"    public:\n"
"        scoped_lock() : my_mutex_ptr(nullptr), my_writer_flag(false) {}\n"
"        scoped_lock(SharedMutexWrapper& mutex, bool write = true)\n"
"            : my_mutex_ptr(&mutex), my_writer_flag(write)\n"
"        {\n"
"            if (my_writer_flag) {\n"
"                my_mutex_ptr->my_mutex.lock();\n"
"            } else {\n"
"                my_mutex_ptr->my_mutex.lock_shared();\n"
"            }\n"
"        }\n"
"\n"
"        ~scoped_lock() {\n"
"            if (my_mutex_ptr) release();\n"
"        }\n"
"\n"
"        void acquire(SharedMutexWrapper& mutex, bool write = true) {\n"
"            if (my_mutex_ptr) release();\n"
"\n"
"            my_mutex_ptr = &mutex;\n"
"            my_writer_flag = write;\n"
"\n"
"            if (my_writer_flag) {\n"
"                my_mutex_ptr->my_mutex.lock();\n"
"            } else {\n"
"                my_mutex_ptr->my_mutex.lock_shared();\n"
"            }\n"
"        }\n"
"\n"
"        void release() {\n"
"            if (my_writer_flag) {\n"
"                my_mutex_ptr->my_mutex.unlock();\n"
"            } else {\n"
"                my_mutex_ptr->my_mutex.unlock_shared();\n"
"            }\n"
"        }\n"
"\n"
"        bool upgrade_to_writer() {\n"
"            // std::shared_mutex does not have the upgrade/downgrade "
"parallel_for_each_semantics\n"
"            if (my_writer_flag) return true; // Already a writer\n"
"\n"
"            my_mutex_ptr->my_mutex.unlock_shared();\n"
"            my_mutex_ptr->my_mutex.lock();\n"
"            return false; // The lock was reacquired\n"
"        }\n"
"\n"
"        bool downgrade_to_reader() {\n"
"            if (!my_writer_flag) return true; // Already a reader\n"
"\n"
"            my_mutex_ptr->my_mutex.unlock();\n"
"            my_mutex_ptr->my_mutex.lock_shared();\n"
"            return false;\n"
"        }\n"
"\n"
"        bool is_writer() const {\n"
"            return my_writer_flag;\n"
"        }\n"
"\n"
"    private:\n"
"        SharedMutexWrapper* my_mutex_ptr;\n"
"        bool                my_writer_flag;\n"
"    };\n"
"private:\n"
"    std::shared_mutex my_mutex;\n"
"}; // struct SharedMutexWrapper\n"
"\n"
"int main() {\n"
"    using map_type = oneapi::tbb::concurrent_hash_map<int, int,\n"
"                                                      "
"oneapi::tbb::tbb_hash_compare<int>,\n"
"                                                      "
"oneapi::tbb::tbb_allocator<std::pair<const int, int>>,\n"
"                                                      "
"SharedMutexWrapper>;\n"
"\n"
"    map_type map; // This object will use SharedMutexWrapper for thread "
"safety of insert/find/erase operations\n"
"}"
msgstr ""

